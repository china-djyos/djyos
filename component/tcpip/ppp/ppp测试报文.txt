//----------------------------------------------------
// Copyright (c) 2018, Djyos Open source Development team. All rights reserved.

// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:

// 1. Redistributions of source code must retain the above copyright notice,
//    this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright notice,
//    this list of conditions and the following disclaimer in the documentation
//    and/or other materials provided with the distribution.
// 3. As a constituent part of djyos,do not transplant it to other software
//    without specific prior written permission.

// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
//-----------------------------------------------------------------------------
// Copyright (c) 2018，著作权由都江堰操作系统开源开发团队所有。著作权人保留一切权利。
//
// 这份授权条款，在使用者符合以下三条件的情形下，授予使用者使用及再散播本
// 软件包装原始码及二进位可执行形式的权利，无论此包装是否经改作皆然：
//
// 1. 对于本软件源代码的再散播，必须保留上述的版权宣告、本条件列表，以
//    及下述的免责声明。
// 2. 对于本套件二进位可执行形式的再散播，必须连带以文件以及／或者其他附
//    于散播包装中的媒介方式，重制上述之版权宣告、本条件列表，以及下述
//    的免责声明。
// 3. 本软件作为都江堰操作系统的组成部分，未获事前取得的书面许可，不允许移植到非
//    都江堰操作系统环境下运行。

// 免责声明：本软件是本软件版权持有人以及贡献者以现状（"as is"）提供，
// 本软件包装不负任何明示或默示之担保责任，包括但不限于就适售性以及特定目
// 的的适用性为默示性担保。版权持有人及本软件之贡献者，无论任何条件、
// 无论成因或任何责任主义、无论此责任为因合约关系、无过失责任主义或因非违
// 约之侵权（包括过失或其他原因等）而起，对于任何因使用本软件包装所产生的
// 任何直接性、间接性、偶发性、特殊性、惩罚性或任何结果的损害（包括但不限
// 于替代商品或劳务之购用、使用损失、资料损失、利益损失、业务中断等等），
// 不负任何责任，即在该种使用已获事前告知可能会造成此类损害的情形下亦然。
//-----------------------------------------------------------------------------
//author:zhangqf
//date  :下午4:59:55/2017年1月4日
//usage :
//------------------------------------------------------

//standard includes
#include <stdint.h>
#include <stddef.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <string.h>
#include <os.h>
//add your own specified header here
#include <driver.h>
#include <sys/time.h>

#include "sio.h"

#include "osarch.h"

//make the test data here
//lcp
const u8 data1[]= {0x7E,0xFF,0x7D,0x23,0xC0,0x21,0x7D,0x21,0x7D,0x21,0x7D,0x20,0x7D,0x2A,0x7D,0x22,0x7D,0x26,0x7D,0x20,0x7D,0x20,0x7D,0x20,0x7D,0x20,0x58,0x7B,0x7E};
const u8 data2[]={0x7E,0xFF,0x7D,0x23,0xC0,0x21,0x7D,0x21,0x7D,0x24,0x7D,0x20,0x7D,0x39,0x7D,0x22,0x7D,0x26,0x7D,0x20,0x7D,0x20,0x7D,0x20,0x7D,0x20,0x7D,0x23,0x7D,0x25,0xC2,0x23,0x7D,0x25,0x7D,0x25,0x7D,0x26,0x3B,0x4D,0x7D,0x27,0xBC,0x7D,0x27,0x7D,0x22,0x7D,0x28,0x7D,0x22,0x7D,0x23,0xFD,0x7E};
const u8 data3[]={0x7E,0xFF,0x7D,0x23,0xC0,0x21,0x7D,0x22,0x7D,0x21,0x7D,0x20,0x7D,0x2A,0x7D,0x22,0x7D,0x26,0x7D,0x20,0x7D,0x20,0x7D,0x20,0x7D,0x20,0x31,0x7D,0x2F,0x7E};
const u8 data4[]={0x7E,0xFF,0x7D,0x23,0xC0,0x21,0x7D,0x24,0x7D,0x24,0x7D,0x20,0x7D,0x28,0x7D,0x27,0x7D,0x22,0x7D,0x28,0x7D,0x22,0x5B,0xB4,0x7E};
const u8 data5[]={0x7E,0xFF,0x7D,0x23,0xC0,0x21,0x7D,0x21,0x7D,0x25,0x7D,0x20,0x7D,0x35,0x7D,0x22,0x7D,0x26,0x7D,0x20,0x7D,0x20,0x7D,0x20,0x7D,0x20,0x7D,0x23,0x7D,0x25,0xC2,0x23,0x7D,0x25,0x7D,0x25,0x7D,0x26,0x3B,0x4D,0x7D,0x27,0xBC,0x7D,0x25,0xD4,0x7E};
const u8 data6[]={0x7E,0xFF,0x7D,0x23,0xC0,0x21,0x7D,0x23,0x7D,0x25,0x7D,0x20,0x7D,0x28,0x7D,0x23,0x7D,0x24,0xC0,0x23,0x54,0x27,0x7E};
const u8 data7[]={0x7E,0xFF,0x7D,0x23,0xC0,0x21,0x7D,0x21,0x7D,0x26,0x7D,0x20,0x7D,0x34,0x7D,0x22,0x7D,0x26,0x7D,0x20,0x7D,0x20,0x7D,0x20,0x7D,0x20,0x7D,0x23,0x7D,0x24,0xC0,0x23,0x7D,0x25,0x7D,0x26,0x3B,0x4D,0x7D,0x27,0xBC,0x60,0x80,0x7E};
const u8 data8[]={0x7E,0xFF,0x7D,0x23,0xC0,0x21,0x7D,0x22,0x7D,0x26,0x7D,0x20,0x7D,0x34,0x7D,0x22,0x7D,0x26,0x7D,0x20,0x7D,0x20,0x7D,0x20,0x7D,0x20,0x7D,0x23,0x7D,0x24,0xC0,0x23,0x7D,0x25,0x7D,0x26,0x3B,0x4D,0x7D,0x27,0xBC,0x8B,0xE9,0x7E};
const u8 data9[]={0x7E,0xFF,0x7D,0x23,0xC0,0x21,0x7D,0x2B,0x7D,0x27,0x7D,0x20,0x7D,0x28,0x3B,0x4D,0x7D,0x27,0xBC,0xCD,0xE5,0x7E};

//auth
const u8 data10[]={0x7E,0xFF,0x03,0xC0,0x23,0x01,0x02,0x00,0x06,0x00,0x00,0x4D,0x34,0x7E};
const u8 data11[]={0x7E,0xFF,0x03,0xC0,0x23,0x02,0x02,0x00,0x05,0x00,0x46,0x1E,0x7E};
//ipcp
const u8 data12[]={0x7E,0xFF,0x03,0x80,0x21,0x01,0x03,0x00,0x16,0x03,0x06,0x00,0x00,0x00,0x00,0x81,0x06,0x00,0x00,0x00,0x00,0x83,0x06,0x00,0x00,0x00,0x00,0xB6,0xB5,0x7E};
const u8 data13[]={0x7E,0xFF,0x03,0x80,0x21,0x01,0x01,0x00,0x04,0x00,0xB7,0x7E};
const u8 data14[]={0x7E,0xFF,0x03,0x80,0x21,0x03,0x03,0x00,0x16,0x03,0x06,0x0A,0xC3,0x6C,0x90,0x81,0x06,0xDD,0xB3,0x26,0x07,0x83,0x06,0x78,0xC4,0xA5,0x07,0xDE,0x60,0x7E};
const u8 data15[]={0x7E,0xFF,0x03,0x80,0x21,0x02,0x01,0x00,0x04,0xCD,0x92,0x7E};
const u8 data16[]={0x7E,0xFF,0x03,0x80,0x21,0x01,0x04,0x00,0x16,0x03,0x06,0x0A,0xC3,0x6C,0x90,0x81,0x06,0xDD,0xB3,0x26,0x07,0x83,0x06,0x78,0xC4,0xA5,0x07,0x71,0xBE,0x7E};
const u8 data17[]={0x7E,0xFF,0x03,0x80,0x21,0x02,0x04,0x00,0x16,0x03,0x06,0x0A,0xC3,0x6C,0x90,0x81,0x06,0xDD,0xB3,0x26,0x07,0x83,0x06,0x78,0xC4,0xA5,0x07,0x87,0x4D,0x7E};
typedef struct
{
    u8*data;
    u16 len;
}tagTestFrame;
const tagTestFrame  gTestData[]={
        //lcp
        {data1,sizeof(data1)},\
        {data2,sizeof(data2)},\
        {data3,sizeof(data3)},\
        {data4,sizeof(data4)},\
        {data5,sizeof(data5)},\
        {data6,sizeof(data6)},\
        {data7,sizeof(data7)},\
        {data8,sizeof(data8)},\
        {data9,sizeof(data9)},\
        //pap
        {data10,sizeof(data10)},\
        {data11,sizeof(data11)},\
        //ipcp
        {data12,sizeof(data12)},\
        {data13,sizeof(data13)},\
        {data14,sizeof(data14)},\
        {data15,sizeof(data15)},\
        {data16,sizeof(data16)},\
        {data17,sizeof(data17)},\
};
#define CN_TEST_FRAME_NUM   (sizeof(gTestData)/sizeof(tagTestFrame))



static int gDebugMode = 1; //0, no debug info;1,print char;2,print hex
bool_t DebugModeSet(int level)
{
    gDebugMode = level;
    return true;
}


//-----------------------------------------------------------------------------
//功能:weuse,0xthis,0xfunction,0xto open the serial device
//参数:
//返回:NULL open failed else the device handle
//备注:
//作者:zhangqf@下午4:55:51/2017年1月5日
//-----------------------------------------------------------------------------
ptu32_t sio_open(const char *name)
{
    ptu32_t result = 0;
    result = (ptu32_t)Driver_OpenDevice(name,O_RDWR,0);
    if(0 == result)
    {
        printf("%s:open %s failed\n\r",__FUNCTION__,name);
    }
    else
    {
        printf("%s:open %s success\n\r",__FUNCTION__,name);
    }
    return result;
}
#define CN_UART_RT_TIMEOUT (1000*mS)
//-----------------------------------------------------------------------------
//功能:we use this function to read data from the serial device
//参数:dev,device handle;buf,data buf to read;len,data len
//返回:-1 if the read abort others  the read len
//备注:do the block read
//作者:zhangqf@下午4:57:17/2017年1月5日
//-----------------------------------------------------------------------------
int sio_read(ptu32_t dev,u8 *buf,u16 buflen,u32 timeout)
{
    static u8 gPrintEnd = 0;

    int i = 0;
    int len = 0;
    len = Driver_ReadDevice((struct DjyDevice *)dev,buf,buflen,0,timeout);
    if(gDebugMode)
    {
        if(len > 0)
        {
            gPrintEnd = 1;
            //print all the data
            time_t printtime;
            printtime = time(NULL);
            printf("[read:%s]",ctime(&printtime));
            for(i = 0;i < len;i++)
            {
                if(gDebugMode == 1)
                {
                    printf("%c",buf[i]);
                }
                else if(gDebugMode ==2)
                {
                    printf("%02x ",buf[i]);
                }
            }
        }
        else
        {
            //maybe timeout
            if(gPrintEnd)
            {
                printf("\n\r");
                gPrintEnd = 0;
            }
        }
    }
    return len;
}


//-----------------------------------------------------------------------------
//功能:we use this function to write data to the serial device
//参数:dev,device handle;buf,data buf to write;len,data len
//返回:
//备注:do the block send
//作者:zhangqf@下午4:57:17/2017年1月5日
//-----------------------------------------------------------------------------
int sio_write(ptu32_t dev,u8 *buf,u16 len)
{
    if(gDebugMode)
    {
        time_t printtime;
        printtime = time(NULL);
        printf("[send:%s]",ctime(&printtime));
        for(u16 i=0;i <len;i++)
        {
            if(gDebugMode == 1)
            {
                printf("%c",buf[i]);
            }
            else if(gDebugMode ==2)
            {
                printf("%02x ",buf[i]);
            }
        }
        printf("\n\r");
    }
    Driver_WriteDevice((struct DjyDevice *)dev,buf,len,0,CN_BLOCK_BUFFER,CN_UART_RT_TIMEOUT);
    return len;
}
//-----------------------------------------------------------------------------
//功能:use this function to close the sio device
//参数:
//返回:
//备注:
//作者:zhangqf@下午5:05:27/2017年1月5日
//-----------------------------------------------------------------------------
bool_t sio_close(ptu32_t dev)
{
    return true;
}


