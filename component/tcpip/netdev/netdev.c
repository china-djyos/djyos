//-----------------------------------------------------------------------------
// Copyright (c) 2018, Djyos Open source Development team. All rights reserved.

// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:

// 1. Redistributions of source code must retain the above copyright notice,
//    this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright notice,
//    this list of conditions and the following disclaimer in the documentation
//    and/or other materials provided with the distribution.
// 3. As a constituent part of djyos,do not transplant it to other software
//    without specific prior written permission.

// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
//-----------------------------------------------------------------------------
// Copyright (c) 2018，著作权由都江堰操作系统开源开发团队所有。著作权人保留一切权利。
//
// 这份授权条款，在使用者符合以下三条件的情形下，授予使用者使用及再散播本
// 软件包装原始码及二进位可执行形式的权利，无论此包装是否经改作皆然：
//
// 1. 对于本软件源代码的再散播，必须保留上述的版权宣告、本条件列表，以
//    及下述的免责声明。
// 2. 对于本套件二进位可执行形式的再散播，必须连带以文件以及／或者其他附
//    于散播包装中的媒介方式，重制上述之版权宣告、本条件列表，以及下述
//    的免责声明。
// 3. 本软件作为都江堰操作系统的组成部分，未获事前取得的书面许可，不允许移植到非
//    都江堰操作系统环境下运行。

// 免责声明：本软件是本软件版权持有人以及贡献者以现状（"as is"）提供，
// 本软件包装不负任何明示或默示之担保责任，包括但不限于就适售性以及特定目
// 的的适用性为默示性担保。版权持有人及本软件之贡献者，无论任何条件、
// 无论成因或任何责任主义、无论此责任为因合约关系、无过失责任主义或因非违
// 约之侵权（包括过失或其他原因等）而起，对于任何因使用本软件包装所产生的
// 任何直接性、间接性、偶发性、特殊性、惩罚性或任何结果的损害（包括但不限
// 于替代商品或劳务之购用、使用损失、资料损失、利益损失、业务中断等等），
// 不负任何责任，即在该种使用已获事前告知可能会造成此类损害的情形下亦然。
//-----------------------------------------------------------------------------

#include <netbsp.h>
#include <osarch.h>
#include "dbug.h"
#include <shell.h>
#include "../component_config_tcpip.h"

#include "../common/link.h"

//first we should implement the device layer
struct NetDev
{
    void                *nxt;                    //dev chain
    char                name[CN_TCPIP_NAMELEN]; //dev name
    u8                  iftype;   //dev type
    fnIfSend            ifsend;   //dev snd function
//  fnIfRecv            ifrecv;   //dev receive function
    fnIfCtrl            ifctrl;   //dev ctrl or stat get fucntion
    struct LinkOps     *linkops;  //dev link operations
    fnNetDevEventHook   eventhook;//dev event hook dealer
    u32                 devfunc;  //dev hard function,such as tcp chksum
    u16                 mtu;      //dev mtu
    void                *Private;  //the dev driver use this to has its owner property
    u8                  mac[CN_MACADDR_LEN];   //mac address
    //the following used to debug the net device,show some main status
    u32                 pkgsnd;     //frame send
    u32                 pkgsnderr;  //frame snd failed
    u32                 pkgrcv;     //frame receive
    u32                 pkgrcverr;  //frame receive err
};
typedef struct
{
    mutex_t   lock;
    struct NetDev *lst;
}tagNetDevCB; //interface controller
static tagNetDevCB gIfaceCB;

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-parameter"

void NetDevPkgsndInc(struct NetDev *iface)
{
    iface->pkgsnd++;
}

void NetDevPkgsndErrInc(struct NetDev *iface)
{
    iface->pkgsnderr++;
}

void NetDevPkgrcvInc(struct NetDev *iface)
{
    iface->pkgrcv++;
}

void NetDevPkgrcvErrInc(struct NetDev *iface)
{
    iface->pkgrcverr++;
}

//-----------------------------------------------------------------------------
//功能: 通过名字获取网卡设备控制块指针。
//参数: name，网卡名，NULL则返回第一块网卡
//返回: 网卡指针
//-----------------------------------------------------------------------------
static struct NetDev* __IfGet(const char *name)
{
    struct NetDev* ret = NULL;
    struct NetDev* tmp = gIfaceCB.lst;
    if(NULL == name)
    {
        ret = gIfaceCB.lst;
    }
    else
    {
        while(NULL != tmp)
        {
            if(0 == strcmp(tmp->name,name))
            {
                ret = tmp;
                tmp = NULL;//end the search
            }
            else
            {
                tmp = tmp->nxt;
            }
        }
    }
    return ret;
}



//use this function to send a package from the net device layer
//bool_t NetDevSend(struct NetDev *iface,struct NetPkg *pkg,u32 framelen,u32 devtask)
//{
//    bool_t ret = false;
//
//    if((NULL != iface)&&(NULL != iface->ifsend))
//    {
//        TCPIP_DEBUG_INC((iface)->pkgsnd);
//        ret =iface->ifsend(iface,pkg,framelen,devtask);
//        if(ret == false)
//        {
//            TCPIP_DEBUG_INC((iface)->pkgsnderr);
//        }
//    }
//    return ret;
//}
//use this function to receive a package from the net device layer
//bool_t NetDevPush(void *iface,struct NetPkg *pkg)
//{
//    bool_t ret = false;
//    if(NULL != iface)
//    {
//        TCPIP_DEBUG_INC(((struct NetDev *)iface)->pkgrcv);
//        ret = LinkDeal(iface,pkg);
//        if(ret == false)
//        {
//            TCPIP_DEBUG_INC(((struct NetDev *)iface)->pkgrcverr);
//        }
//    }
//    return ret;
//}

//-----------------------------------------------------------------------------
//功能: 通过网卡设备控制块指针获取网卡名
//参数: DevFace，网络控制块指针
//返回: 网卡名
//-----------------------------------------------------------------------------
const char *NetDevName(struct NetDev *DevFace)
{
    if(NULL!= DevFace)
    {
        return (const char *)(DevFace->name);
    }
    else
    {
        return NULL;
    }
}

//-----------------------------------------------------------------------------
//功能: 通过名字获取网卡设备控制块指针。
//参数: name，网卡名，NULL则返回第一块网卡
//返回: 网卡指针
//-----------------------------------------------------------------------------
struct NetDev *NetDevGet(const char *ifname)
{
    struct NetDev * ret = NULL;
    if(mutex_lock(gIfaceCB.lock))
    {
        ret = __IfGet(ifname);
        mutex_unlock(gIfaceCB.lock);
    }
    return ret;
}
//-----------------------------------------------------------------------------
//功能: 获取网卡附加功能，参见netbsp.h中的 CN_IPDEV_TCPOCHKSUM 等定义
//参数: DevFace，网络控制块指针
//返回: 网卡名
//-----------------------------------------------------------------------------
u32 NetDevFunc(struct NetDev *DevFace)
{
    if(NULL!= DevFace)
    {
        return DevFace->devfunc;
    }
    else
    {
        return 0;
    }
}
//get the interface mtu for external module
u16 NetDevMtu(struct NetDev *DevFace)
{
    if(NULL!= DevFace)
    {
        return (DevFace)->mtu;
    }
    else
    {
        return 0;
    }
}
//-----------------------------------------------------------------------------
//功能: 获取网卡类型，参见netbsp.h中的 EN_LINK_LAST 等定义
//参数: DevFace，网络控制块指针
//返回: 网卡类型
//-----------------------------------------------------------------------------
enum enLinkType NetDevType(struct NetDev *DevFace)
{
    enum enLinkType ret = EN_LINK_LAST;
    if(NULL != DevFace)
    {
        ret = (DevFace)->iftype;
    }
    return ret;
}
//-----------------------------------------------------------------------------
//功能: 获取网卡链路层收发函数集指针
//参数: DevFace，网络控制块指针
//返回: 函数集指针
//-----------------------------------------------------------------------------
struct LinkOps *NetDevLinkOps(struct NetDev *DevFace)
{
    struct LinkOps *ret = NULL;
    if(NULL != DevFace)
    {
        ret = (DevFace)->linkops;
    }
    return ret;
}
//-----------------------------------------------------------------------------
//功能: 获取网卡的Mac地址，按网络字节序的buffer。
//参数: DevFace，网络控制块指针
//返回: Mac地址指针
//-----------------------------------------------------------------------------
const u8 *NetDevGetMac(struct NetDev *DevFace)
{
    if(NULL!= DevFace)
    {
        return (const u8 *)((DevFace)->mac);
    }
    else
    {
        return NULL;
    }
}

//-----------------------------------------------------------------------------
//功能: 默认网卡事件监听钩子，APP可以调用 NetDevRegisterEventHook 函数重新设置，只打印
//      信息，其他什么都不做。
//参数: iface，网络控制块指针
//      event，网卡事件，参见 EN_NETDEVEVENT_LINKDOWN 等定义
//返回: true
//-----------------------------------------------------------------------------
static bool_t __NetdevEventHook(struct NetDev *iface,enum NetDevEvent event)
{
    switch(event)
    {
        case EN_NETDEVEVENT_LINKDOWN:
            debug_printf("netdev","link is down\n\r");  //warning the app to do some notice
            break;
        case EN_NETDEVEVENT_LINKUP:
            debug_printf("netdev","link is up\n\r"); //warning the app to do some notice
            break;
        case EN_NETDEVEVENT_IPGET:
            debug_printf("netdev","ip get\n\r"); //warning the app to do some notice
            break;
        case EN_NETDEVEVENT_IPRELEASE:
            debug_printf("netdev","ip release\n\r"); //warning the app to do some notice
            break;
        case EN_NETDEVEVENT_BROAD_OVER:
            //should shutdown the receive broad frame of the net device
            debug_printf("netdev","broad strom has come,stop rcv the broadcast\n\r");
            break;
        case EN_NETDEVEVENT_BROAD_LACK:
            //should open the receive broad frame of the net device
            debug_printf("netdev","broad strom has gone,rcv the broadcast\n\r");
            break;

        case EN_NETDEVEVENT_MULTI_OVER:
            //should shutdown the receive broad frame of the net device
            debug_printf("netdev","MULTI strom has come,stop rcv the multi\n\r");
            break;
        case EN_NETDEVEVENT_MULTI_LACK:
            //should open the receive broad frame of the net device
            debug_printf("netdev","MULTI strom has gone,rcv the multi\n\r");
            break;
        case EN_NETDEVEVENT_POINT_OVER:
            //should shutdown the receive broad frame of the net device
            debug_printf("netdev","point strom has come,stop rcv the point\n\r");
            break;
        case EN_NETDEVEVENT_POINT_LACK:
            //should open the receive broad frame of the net device
            debug_printf("netdev","point strom has gone,rcv the point\n\r");
            break;
        case EN_NETDEVEVENT_FLOW_OVER:
            //maybe some err happened to the device,should reset
            debug_printf("netdev","flow over has come\n\r");
            break;
        case EN_NETDEVEVENT_FLOW_LACKNetDevSend:
            //the net work comes to normal
            debug_printf("netdev","flow lack has COME,reset the net device\n\r");
            break;
        case EN_NETDEVEVENT_RESET:
            debug_printf("netdev","dev reset\n\r"); //should do some log here
            break;
        default:
            debug_printf("netdev","unknown event\n\r"); //should ignore here
            break;
    }
    return true;
}

//-----------------------------------------------------------------------------
//功能: 安装网卡。
//参数: para，参数，见 struct NetDevPara 定义
//返回: 网卡控制块指针
//-----------------------------------------------------------------------------
struct NetDev* NetDevInstall(struct NetDevPara *para)
{
    struct NetDev* iface = NULL;
    struct LinkOps *linkops;
    if(NULL == para)
    {
        return iface;
    }
    linkops = LinkFindOps(para->iftype);
    if(NULL == linkops)
    {
        return iface;
    }

    if(mutex_lock(gIfaceCB.lock))
    {
        iface = __IfGet(para->name);
        if(NULL == iface)
        {
            iface = net_malloc(sizeof(struct NetDev));
            if(NULL != iface)
            {
                //fill the dev
                memset(iface, 0, sizeof(struct NetDev));
                strncpy(iface->name,para->name,CN_TCPIP_NAMELEN);
                memcpy(iface->mac, para->mac, CN_MACADDR_LEN);
                iface->ifsend  = para->ifsend;
//              iface->ifrecv = para->ifrecv;
                iface->ifctrl  = para->ifctrl;
                iface->linkops = linkops;
                iface->eventhook = __NetdevEventHook;
                iface->Private = para->Private;
                iface->iftype = para->iftype;
                iface->mtu= para->mtu;
                iface->devfunc= para->devfunc;
                //add it to the dev chain
                iface->nxt = gIfaceCB.lst;
                gIfaceCB.lst = iface;
            }
        }
        mutex_unlock(gIfaceCB.lock);
    }
    return iface;
}

//-----------------------------------------------------------------------------
//功能: 卸载网卡。
//参数: name，网卡名
//返回: true  or false
//-----------------------------------------------------------------------------
bool_t  NetDevUninstall(const char *name)
{
    struct NetDev* tmp;
    struct NetDev* bak;
    bool_t     result = false;

    if(mutex_lock(gIfaceCB.lock))
    {
        tmp = gIfaceCB.lst;
        bak = tmp;
        while(NULL != tmp)
        {
            if(0 == strcmp(tmp->name,name))
            {
                //bingo,we got it now
                //remove it from the dev chain
                if(tmp == gIfaceCB.lst)
                {
                    //the head one
                    gIfaceCB.lst = tmp->nxt;
                }
                else
                {
                    bak->nxt = tmp->nxt;
                }
                //net_free the device memory now
                net_free((void *)tmp);
                result = true;
                break;
            }
            else
            {
                bak = tmp;
                tmp = tmp->nxt;
            }
        }
        mutex_unlock(gIfaceCB.lock);
    }
    return result;
}

//-----------------------------------------------------------------------------
//功能: 设置网卡事件钩子函数，若不设置，则使用默认的 __NetdevEventHook 函数
//参数: handle，由 NetDevInstall 返回的网卡控制块指针
//      hook，钩子函数
//返回: true or false
//-----------------------------------------------------------------------------
bool_t NetDevRegisterEventHook(struct NetDev *handle,fnNetDevEventHook hook)
{
    bool_t result = false;
    if(mutex_lock(gIfaceCB.lock))
    {
        if(NULL != handle)
        {
            handle->eventhook = hook;
            result = true;
        }
        mutex_unlock(gIfaceCB.lock);
    }
    return result;
}

//-----------------------------------------------------------------------------
//功能: 卸载网卡事件钩子函数,卸载后，使用默认的 __NetdevEventHook 函数
//参数: handle，由 NetDevInstall 返回的网卡控制块指针
//返回: true or false
//-----------------------------------------------------------------------------
bool_t NetDevUnRegisterEventHook(struct NetDev * handle)
{
    bool_t result = false;

    if(mutex_lock(gIfaceCB.lock))
    {
        if(NULL != handle)
        {
            handle->eventhook = __NetdevEventHook;
            result = true;
        }
        mutex_unlock(gIfaceCB.lock);
    }
    return result;
}

//-----------------------------------------------------------------------------
//功能: 抛出网卡事件，将由 dev->eventhook 函数响应
//参数: handle，由 NetDevInstall 返回的网卡控制块指针
//      event，被抛出的网卡事件
//返回: true or false
//-----------------------------------------------------------------------------
bool_t NetDevPostEvent(struct NetDev* handle,enum NetDevEvent event)
{
    bool_t result = false;
    struct NetDev* iface = NULL;
    fnNetDevEventHook hook= NULL;
    if(NULL != handle)
    {
        return false;
    }
    if(mutex_lock(gIfaceCB.lock))
    {
        if(NULL != iface)
        {
            hook =iface->eventhook;
        }
        mutex_unlock(gIfaceCB.lock);
        if(NULL != hook)
        {
            result = hook(iface,event);
        }
    }
    return result;
}

//-----------------------------------------------------------------------------
//功能: 网卡发送函数，
//参数: handle，由 NetDevInstall 返回的网卡控制块指针
//      pkglst，待发送的包
//      framlen，发送数据长度
//      netdevtask，网卡功能
//返回: true or false
//-----------------------------------------------------------------------------
bool_t  NetDevSend(struct NetDev* handle,struct NetPkg *pkglst,u32 framlen,u32 netdevtask)
{
    bool_t     ret = false;

    if(NULL !=handle)
    {
        ret = handle->ifsend(handle,pkglst,framlen,netdevtask);
    }
    return ret;
}

//-----------------------------------------------------------------------------
//功能: 网卡控制函数，功能由 cmd 决定。
//参数: handle，由 NetDevInstall 返回的网卡控制块指针
//      cmd，命令码
//      para，命令参数
//返回: true or false
//-----------------------------------------------------------------------------
bool_t  NetDevCtrl(struct NetDev* handle,enNetDevCmd cmd, ptu32_t para)
{
    bool_t     ret = false;
    struct NetDev* dev;

    dev = handle;
    if((NULL !=dev)&&(NULL != dev->ifctrl))
    {
        ret = dev->ifctrl(dev,cmd,para);
        if(ret &&(cmd == EN_NETDEV_SETMAC))
        {
            memcpy(dev->mac,(u8 *)para,CN_MACADDR_LEN);
        }
    }
    return ret;
}

//-----------------------------------------------------------------------------
//功能: 取网卡的私有指针
//参数: DevFace，由 NetDevInstall 返回的网卡控制块指针
//返回: true or false
//-----------------------------------------------------------------------------
void * NetDevPrivate(struct NetDev *iface)
{
    void *ret = NULL;
    if(NULL != iface)
    {
        ret = (iface)->Private;
    }
    return ret;
}

//netdev shell here
//static bool_t __IfconfigShell(char *param)
bool_t ifconfig(char *param)
{
    int i = 0;
    struct NetDev *iface;
    OsPrintSplit('*',100);
    debug_printf("netdev","%-2s %-10s %-10s %-8s %-8s %-8s %-8s %-8s %-8s %-s\n\r",\
            "NO","NAME","TYPE","FUNCTION","MTU","SNDTOTAL","SNDERR","RCVTOTAL","RCVERR","MAC");
    if(mutex_lock(gIfaceCB.lock))
    {
        iface = gIfaceCB.lst;
        while(NULL != iface)
        {
            i++;
            debug_printf("netdev","%-2d %-10s %-10s %-8x %-8x %-8x %-8x %-8x %-8x %-s\n\r",\
                    i,iface->name,LinkTypeName(iface->iftype),iface->devfunc,iface->mtu,\
                    iface->pkgsnd,iface->pkgsnderr,iface->pkgrcv,iface->pkgrcverr,mac2string(iface->mac));
            iface = iface->nxt;
        }
        mutex_unlock(gIfaceCB.lock);
    }
    OsPrintSplit('*',100);
    return true;
}
//-----------------------------------------------------------------------------
//功能: 网络设备接口初始化
//参数: 无
//返回: true or false
//-----------------------------------------------------------------------------
bool_t NetDevInit(void)
{
    bool_t ret = false;
    gIfaceCB.lst = NULL;
    gIfaceCB.lock = mutex_init(NULL);
    if(NULL == gIfaceCB.lock)
    {
        goto EXIT_MUTEX;
    }

    ret = true;
    return ret;


EXIT_MUTEX:
    ret = false;
    return ret;
}

ADD_TO_ROUTINE_SHELL(ifconfig,ifconfig,"usage:ifconfig");
#pragma GCC diagnostic pop
