//-----------------------------------------------------------------------------
// Copyright (c) 2018, Djyos Open source Development team. All rights reserved.

// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:

// 1. Redistributions of source code must retain the above copyright notice,
//    this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright notice,
//    this list of conditions and the following disclaimer in the documentation
//    and/or other materials provided with the distribution.
// 3. As a constituent part of djyos,do not transplant it to other software
//    without specific prior written permission.

// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
//-----------------------------------------------------------------------------
// Copyright (c) 2018，著作权由都江堰操作系统开源开发团队所有。著作权人保留一切权利。
//
// 这份授权条款，在使用者符合以下三条件的情形下，授予使用者使用及再散播本
// 软件包装原始码及二进位可执行形式的权利，无论此包装是否经改作皆然：
//
// 1. 对于本软件源代码的再散播，必须保留上述的版权宣告、本条件列表，以
//    及下述的免责声明。
// 2. 对于本套件二进位可执行形式的再散播，必须连带以文件以及／或者其他附
//    于散播包装中的媒介方式，重制上述之版权宣告、本条件列表，以及下述
//    的免责声明。
// 3. 本软件作为都江堰操作系统的组成部分，未获事前取得的书面许可，不允许移植到非
//    都江堰操作系统环境下运行。

// 免责声明：本软件是本软件版权持有人以及贡献者以现状（"as is"）提供，
// 本软件包装不负任何明示或默示之担保责任，包括但不限于就适售性以及特定目
// 的的适用性为默示性担保。版权持有人及本软件之贡献者，无论任何条件、
// 无论成因或任何责任主义、无论此责任为因合约关系、无过失责任主义或因非违
// 约之侵权（包括过失或其他原因等）而起，对于任何因使用本软件包装所产生的
// 任何直接性、间接性、偶发性、特殊性、惩罚性或任何结果的损害（包括但不限
// 于替代商品或劳务之购用、使用损失、资料损失、利益损失、业务中断等等），
// 不负任何责任，即在该种使用已获事前告知可能会造成此类损害的情形下亦然。
//-----------------------------------------------------------------------------

#include <netbsp.h>
#include <osarch.h>
#include "dbug.h"
#include <shell.h>
#include "../component_config_tcpip.h"

#include "../common/link.h"

typedef struct
{
//  vu32       enable:1;             //enable it or not
//  vu32       uaction:1;            //if more than the upperlimit then set it
//  vu32       laction:1;            //if less than lower limit then set it
//  vu32       lactionb:5;           //low begin message
//  vu32       lactione:5;           //low end message
//  vu32       uactionb:5;           //upper begin message
//  vu32       uactione:5;           //upper end message

    bool_t     en;                   //means the filter en or not
    bool_t     overaction;           //means over the upper limit and action now
    bool_t     lackaction;           //means less than the floor limit and action
    vu32       overevent;            //means over action event to post
    vu32       lackevent;            //means lack action event to post
    vu32       actiontimes;          //which means the action total times
    vu32       fcounter;             //which means how many frame received
    vu32       fulimit;              //which means the upper limit
    vu32       fllimit;              //which means the lower limit
    vu32       period;               //which means the measure period
    vu64       ftotal;               //which means the total frame of the type
    vs64       deadtime;             //which means the measure end time
}tagNetDevRcvFilter;
//first we should implement the device layer
struct NetDev
{
    struct NetDev      *nxt;                    //dev chain
    char                name[CN_TCPIP_NAMELEN]; //dev name
    u8                  iftype;   //dev type
    fnIfSend            ifsend;   //dev snd function
//  fnIfRecv            ifrecv;   //dev receive function
    fnIfCtrl            ifctrl;   //dev ctrl or stat get fucntion
    struct LinkOps     *linkops;  //dev link operations
    fnNetDevEventHook   eventhook;//dev event hook dealer
    u32                 devfunc;  //dev hard function,such as tcp chksum
    u16                 mtu;      //dev mtu
    void                *Private;  //the dev driver use this to has its owner property
    u8                  mac[CN_MACADDR_LEN];   //mac address
    //the following used to debug the net device,show some main status
    u32                 pkgsnd;     //frame send
    u32                 pkgsnderr;  //frame snd failed
    u32                 pkgrcv;     //frame receive
    u32                 pkgrcverr;  //frame receive err
    tagNetDevRcvFilter  rfilter[EN_NETDEV_FRAME_LAST];  //the recv filter
};
struct NetDevCB
{
    mutex_t   lock;
    struct NetDev *lst;
}; //interface controller
static struct NetDevCB gIfaceCB;

void NetDevPkgsndInc(struct NetDev *iface)
{
    iface->pkgsnd++;
}

void NetDevPkgsndErrInc(struct NetDev *iface)
{
    iface->pkgsnderr++;
}

void NetDevPkgrcvInc(struct NetDev *iface)
{
    iface->pkgrcv++;
}

void NetDevPkgrcvErrInc(struct NetDev *iface)
{
    iface->pkgrcverr++;
}

//-----------------------------------------------------------------------------
//功能: 通过名字获取网卡设备控制块指针。
//参数: name，网卡名，NULL则返回第一块网卡
//返回: 网卡指针
//-----------------------------------------------------------------------------
static struct NetDev* __NetDevGet(const char *name)
{
    struct NetDev* ret = NULL;
    struct NetDev* tmp = gIfaceCB.lst;
    if(NULL == name)
    {
        ret = gIfaceCB.lst;
    }
    else
    {
        while(NULL != tmp)
        {
            if(0 == strcmp(tmp->name,name))
            {
                ret = tmp;
                tmp = NULL;//end the search
            }
            else
            {
                tmp = tmp->nxt;
            }
        }
    }
    return ret;
}



//use this function to send a package from the net device layer
//bool_t NetDevSend(struct NetDev *iface,struct NetPkg *pkg,u32 framelen,u32 devtask)
//{
//    bool_t ret = false;
//
//    if((NULL != iface)&&(NULL != iface->ifsend))
//    {
//        TCPIP_DEBUG_INC((iface)->pkgsnd);
//        ret =iface->ifsend(iface,pkg,framelen,devtask);
//        if(ret == false)
//        {
//            TCPIP_DEBUG_INC((iface)->pkgsnderr);
//        }
//    }
//    return ret;
//}
//use this function to receive a package from the net device layer
//bool_t NetDevPush(void *iface,struct NetPkg *pkg)
//{
//    bool_t ret = false;
//    if(NULL != iface)
//    {
//        TCPIP_DEBUG_INC(((struct NetDev *)iface)->pkgrcv);
//        ret = LinkDeal(iface,pkg);
//        if(ret == false)
//        {
//            TCPIP_DEBUG_INC(((struct NetDev *)iface)->pkgrcverr);
//        }
//    }
//    return ret;
//}

//-----------------------------------------------------------------------------
//功能: 通过网卡设备控制块指针获取网卡名
//参数: DevFace，网络控制块指针
//返回: 网卡名
//-----------------------------------------------------------------------------
const char *NetDevName(struct NetDev *DevFace)
{
    if(NULL!= DevFace)
    {
        return (const char *)(DevFace->name);
    }
    else
    {
        return NULL;
    }
}

//-----------------------------------------------------------------------------
//功能: 通过名字获取网卡设备控制块指针。
//参数: name，网卡名，NULL则返回第一块网卡
//返回: 网卡指针
//-----------------------------------------------------------------------------
struct NetDev *NetDevGet(const char *ifname)
{
    struct NetDev * ret = NULL;
    if(mutex_lock(gIfaceCB.lock))
    {
        ret = __NetDevGet(ifname);
        mutex_unlock(gIfaceCB.lock);
    }
    return ret;
}
//-----------------------------------------------------------------------------
//功能: 获取网卡附加功能，参见netbsp.h中的 CN_IPDEV_TCPOCHKSUM 等定义
//参数: DevFace，网络控制块指针
//返回: 网卡名
//-----------------------------------------------------------------------------
u32 NetDevFunc(struct NetDev *DevFace)
{
    if(NULL!= DevFace)
    {
        return DevFace->devfunc;
    }
    else
    {
        return 0;
    }
}
//get the interface mtu for external module
u16 NetDevMtu(struct NetDev *DevFace)
{
    if(NULL!= DevFace)
    {
        return (DevFace)->mtu;
    }
    else
    {
        return 0;
    }
}
//-----------------------------------------------------------------------------
//功能: 获取网卡类型，参见netbsp.h中的 EN_LINK_LAST 等定义
//参数: DevFace，网络控制块指针
//返回: 网卡类型
//-----------------------------------------------------------------------------
enum enLinkType NetDevType(struct NetDev *DevFace)
{
    enum enLinkType ret = EN_LINK_LAST;
    if(NULL != DevFace)
    {
        ret = (DevFace)->iftype;
    }
    return ret;
}
//-----------------------------------------------------------------------------
//功能: 获取网卡链路层收发函数集指针
//参数: DevFace，网络控制块指针
//返回: 函数集指针
//-----------------------------------------------------------------------------
struct LinkOps *NetDevLinkOps(struct NetDev *DevFace)
{
    struct LinkOps *ret = NULL;
    if(NULL != DevFace)
    {
        ret = (DevFace)->linkops;
    }
    return ret;
}
//-----------------------------------------------------------------------------
//功能: 获取网卡的Mac地址，按网络字节序的buffer。
//参数: DevFace，网络控制块指针
//返回: Mac地址指针
//-----------------------------------------------------------------------------
const u8 *NetDevGetMac(struct NetDev *DevFace)
{
    if(NULL!= DevFace)
    {
        return (const u8 *)((DevFace)->mac);
    }
    else
    {
        return NULL;
    }
}

//-----------------------------------------------------------------------------
//功能: 默认网卡事件监听钩子，APP可以调用 NetDevRegisterEventHook 函数重新设置，只打印
//      信息，其他什么都不做。
//参数: iface，网络控制块指针
//      event，网卡事件，参见 EN_NETDEVEVENT_LINKDOWN 等定义
//返回: true
//-----------------------------------------------------------------------------
static bool_t __NetdevEventHook(struct NetDev *iface,enum NetDevEvent event)
{
    switch(event)
    {
        case EN_NETDEVEVENT_LINKDOWN:
            debug_printf("netdev","link is down\n\r");  //warning the app to do some notice
            break;
        case EN_NETDEVEVENT_LINKUP:
            debug_printf("netdev","link is up\n\r"); //warning the app to do some notice
            break;
        case EN_NETDEVEVENT_IPGET:
            debug_printf("netdev","ip get\n\r"); //warning the app to do some notice
            break;
        case EN_NETDEVEVENT_IPRELEASE:
            debug_printf("netdev","ip release\n\r"); //warning the app to do some notice
            break;
        case EN_NETDEVEVENT_BROAD_OVER:
            //should shutdown the receive broad frame of the net device
            debug_printf("netdev","broad strom has come,stop rcv the broadcast\n\r");
            break;
        case EN_NETDEVEVENT_BROAD_LACK:
            //should open the receive broad frame of the net device
            debug_printf("netdev","broad strom has gone,rcv the broadcast\n\r");
            break;

        case EN_NETDEVEVENT_MULTI_OVER:
            //should shutdown the receive broad frame of the net device
            debug_printf("netdev","MULTI strom has come,stop rcv the multi\n\r");
            break;
        case EN_NETDEVEVENT_MULTI_LACK:
            //should open the receive broad frame of the net device
            debug_printf("netdev","MULTI strom has gone,rcv the multi\n\r");
            break;
        case EN_NETDEVEVENT_POINT_OVER:
            //should shutdown the receive broad frame of the net device
            debug_printf("netdev","point strom has come,stop rcv the point\n\r");
            break;
        case EN_NETDEVEVENT_POINT_LACK:
            //should open the receive broad frame of the net device
            debug_printf("netdev","point strom has gone,rcv the point\n\r");
            break;
        case EN_NETDEVEVENT_FLOW_OVER:
            //maybe some err happened to the device,should reset
            debug_printf("netdev","flow over has come\n\r");
            break;
        case EN_NETDEVEVENT_FLOW_LACK:
            //the net work comes to normal
            debug_printf("netdev","flow lack has COME,reset the net device\n\r");
            break;
        case EN_NETDEVEVENT_RESET:
            debug_printf("netdev","dev reset\n\r"); //should do some log here
            break;
        default:
            debug_printf("netdev","unknown event\n\r"); //should ignore here
            break;
    }
    return true;
}

//-----------------------------------------------------------------------------
//功能: 安装网卡。
//参数: para，参数，见 struct NetDevPara 定义
//返回: 网卡控制块指针
//-----------------------------------------------------------------------------
struct NetDev* NetDevInstall(struct NetDevPara *para)
{
    struct NetDev* iface = NULL;
    struct LinkOps *linkops;
    if(NULL == para)
    {
        return iface;
    }
    linkops = LinkFindOps(para->iftype);
    if(NULL == linkops)
    {
        return iface;
    }

    if(mutex_lock(gIfaceCB.lock))
    {
        iface = __NetDevGet(para->name);
        if(NULL == iface)
        {
            iface = net_malloc(sizeof(struct NetDev));
            if(NULL != iface)
            {
                //fill the dev
                memset(iface, 0, sizeof(struct NetDev));
                strncpy(iface->name,para->name,CN_TCPIP_NAMELEN);
                memcpy(iface->mac, para->mac, CN_MACADDR_LEN);
                iface->ifsend  = para->ifsend;
//              iface->ifrecv = para->ifrecv;
                iface->ifctrl  = para->ifctrl;
                iface->linkops = linkops;
                iface->eventhook = __NetdevEventHook;
                iface->Private = para->Private;
                iface->iftype = para->iftype;
                iface->mtu= para->mtu;
                iface->devfunc= para->devfunc;
                //initialize the dev filter part
                iface->rfilter[EN_NETDEV_FRAME_POINT].en = false;
                iface->rfilter[EN_NETDEV_FRAME_POINT].overevent =EN_NETDEVEVENT_POINT_OVER;
                iface->rfilter[EN_NETDEV_FRAME_POINT].lackevent =EN_NETDEVEVENT_POINT_LACK;
                iface->rfilter[EN_NETDEV_FRAME_MULTI].en = false;
                iface->rfilter[EN_NETDEV_FRAME_MULTI].overevent =EN_NETDEVEVENT_MULTI_OVER;
                iface->rfilter[EN_NETDEV_FRAME_MULTI].lackevent =EN_NETDEVEVENT_MULTI_LACK;
                iface->rfilter[EN_NETDEV_FRAME_BROAD].en = false;
                iface->rfilter[EN_NETDEV_FRAME_BROAD].overevent =EN_NETDEVEVENT_BROAD_OVER;
                iface->rfilter[EN_NETDEV_FRAME_BROAD].lackevent =EN_NETDEVEVENT_BROAD_LACK;
                iface->rfilter[EN_NETDEV_FRAME_ALL   ].en = false;
                iface->rfilter[EN_NETDEV_FRAME_ALL   ].overevent =EN_NETDEVEVENT_FLOW_OVER;
                iface->rfilter[EN_NETDEV_FRAME_ALL   ].lackevent =EN_NETDEVEVENT_FLOW_LACK;
                //add it to the dev chain
                iface->nxt = gIfaceCB.lst;
                gIfaceCB.lst = iface;
            }
            else
            {
                //no more mem for the dev, so failed
                printf("%s:failed--no mem\r\n",__FUNCTION__);
            }
        }
        mutex_unlock(gIfaceCB.lock);
    }
    return iface;
}

//-----------------------------------------------------------------------------
//功能: 卸载网卡。
//参数: name，网卡名
//返回: true  or false
//-----------------------------------------------------------------------------
bool_t  NetDevUninstall(const char *name)
{
    struct NetDev* tmp;
    struct NetDev* bak;
    bool_t     result = false;

    if(mutex_lock(gIfaceCB.lock))
    {
        tmp = gIfaceCB.lst;
        bak = tmp;
        while(NULL != tmp)
        {
            if(0 == strcmp(tmp->name,name))
            {
                //bingo,we got it now
                //remove it from the dev chain
                if(tmp == gIfaceCB.lst)
                {
                    //the head one
                    gIfaceCB.lst = tmp->nxt;
                }
                else
                {
                    bak->nxt = tmp->nxt;
                }
                //net_free the device memory now
                net_free((void *)tmp);
                result = true;
                break;
            }
            else
            {
                bak = tmp;
                tmp = tmp->nxt;
            }
        }
        mutex_unlock(gIfaceCB.lock);
    }
    return result;
}

//-----------------------------------------------------------------------------
//功能: 设置网卡事件钩子函数，若不设置，则使用默认的 __NetdevEventHook 函数
//参数: handle，由 NetDevInstall 返回的网卡控制块指针
//      hook，钩子函数
//返回: true or false
//-----------------------------------------------------------------------------
bool_t NetDevRegisterEventHook(struct NetDev *handle,fnNetDevEventHook hook)
{
    bool_t result = false;
    if(mutex_lock(gIfaceCB.lock))
    {
        if(NULL != handle)
        {
            handle->eventhook = hook;
            result = true;
        }
        mutex_unlock(gIfaceCB.lock);
    }
    return result;
}

//-----------------------------------------------------------------------------
//功能: 卸载网卡事件钩子函数,卸载后，使用默认的 __NetdevEventHook 函数
//参数: handle，由 NetDevInstall 返回的网卡控制块指针
//返回: true or false
//-----------------------------------------------------------------------------
bool_t NetDevUnRegisterEventHook(struct NetDev * handle)
{
    bool_t result = false;

    if(mutex_lock(gIfaceCB.lock))
    {
        if(NULL != handle)
        {
            handle->eventhook = __NetdevEventHook;
            result = true;
        }
        mutex_unlock(gIfaceCB.lock);
    }
    return result;
}

//-----------------------------------------------------------------------------
//功能: 抛出网卡事件，将由 dev->eventhook 函数响应
//参数: handle，由 NetDevInstall 返回的网卡控制块指针
//      event，被抛出的网卡事件
//返回: true or false
//-----------------------------------------------------------------------------
bool_t NetDevPostEvent(struct NetDev* handle,enum NetDevEvent event)
{
    bool_t result = false;
    struct NetDev* iface = handle;
    fnNetDevEventHook hook= NULL;
    if(NULL == handle)
    {
        return false;
    }
    if(mutex_lock(gIfaceCB.lock))
    {
        if(NULL != iface)
        {
            hook =iface->eventhook;
        }
        mutex_unlock(gIfaceCB.lock);
        if(NULL != hook)
        {
            result = hook(iface,event);
        }
    }
    return result;
}

//-----------------------------------------------------------------------------
//功能: 网卡发送函数，
//参数: handle，由 NetDevInstall 返回的网卡控制块指针
//      pkglst，待发送的包
//      framlen，发送数据长度
//      netdevtask，网卡功能
//返回: true or false
//-----------------------------------------------------------------------------
bool_t  NetDevSend(struct NetDev* handle,struct NetPkg *pkglst,u32 netdevtask)
{
    bool_t     ret = false;

    if(NULL !=handle)
    {
        ret = handle->ifsend(handle,pkglst,netdevtask);
    }
    return ret;
}

//-----------------------------------------------------------------------------
//功能: 网卡控制函数，功能由 cmd 决定。
//参数: handle，由 NetDevInstall 返回的网卡控制块指针
//      cmd，命令码
//      para，命令参数
//返回: true or false
//-----------------------------------------------------------------------------
bool_t  NetDevCtrl(struct NetDev* handle,enum NetDevCmd cmd, ptu32_t para)
{
    bool_t     ret = false;
    struct NetDev* dev;

    dev = handle;
    if((NULL !=dev)&&(NULL != dev->ifctrl))
    {
        ret = dev->ifctrl(dev,cmd,para);
        if(ret &&(cmd == EN_NETDEV_SETMAC))
        {
            memcpy(dev->mac,(u8 *)para,CN_MACADDR_LEN);
        }
    }
    return ret;
}

// =============================================================================
//功能：配置网卡的流量控制参数
//参数：handle，网卡设备句柄
//     type，被控制的包类型，netbsp.h中定义
//     llimit，流量下限，在period时间内，收到type类型的包数低于此限，即发送网卡事件
//     ulimit，流量上限，在period时间内，收到type类型的包数超过此限，即发送网卡事件
//     period，流量统计周期
//     enable :1 true while 0 false
// 返回：true success while false failed
// =============================================================================
bool_t NetDevFlowSet(struct NetDev* handle,enNetDevFramType type,\
                     u32 llimit,u32 ulimit,u32 period,int enable)
{
    bool_t result = false;
    tagNetDevRcvFilter *filter;

    if(Lock_MutexPend(gIfaceCB.lock, CN_TIMEOUT_FOREVER))
    {
        if(NULL != handle)
        {
            filter = &handle->rfilter[type];
            filter->period = period;
            filter->fulimit =ulimit;
            filter->fllimit =llimit;
            filter->fcounter = 0;
            filter->deadtime = DjyGetSysTime() + period;
            filter->en = enable?1:0;
            result = true;
        }
        Lock_MutexPost(gIfaceCB.lock);
    }
    return result;
}

// =============================================================================
// FUNCTION   :use this function to check the frame type
// PARAMS IN  :buf, the frame buffer
// PARAMS OUT :
// RETURN     :enNetDevFramType,which type of the frame
// DESCRIPTION:
// =============================================================================
enNetDevFramType NetDevFrameType(u8 *buf,u16 len)
{
    enNetDevFramType result = EN_NETDEV_FRAME_LAST;
    if((NULL != buf)&&(len > CN_MACADDR_LEN))
    {
        if(0 == memcmp(buf,CN_MAC_BROAD,CN_MACADDR_LEN))
        {
            result = EN_NETDEV_FRAME_BROAD;
        }
        else if(buf[0]&0x01)
        {
            result = EN_NETDEV_FRAME_MULTI;
        }
        else
        {
            result = EN_NETDEV_FRAME_POINT;
        }
    }
    return result;
}

//THE OLD ONE IS NOT CORRECT, ONLY THE FRAME BETWEEN THE UPPER AND FLOOR LIMIT IS PROPER
static void __NetDevFlowCheck(struct NetDev* handle,tagNetDevRcvFilter *filter,s64 timenow)
{
    if(filter->en)
    {
        if(timenow > filter->deadtime) //should check if the floor limit is reached
        {
            //check the upper limit
            if(filter->fllimit > filter->fcounter)
            {
                NetDevPostEvent(handle,filter->lackevent);//post a lack message
                filter->lackaction = true;
                filter->actiontimes++;
            }
            else
            {
                filter->lackaction = false;
            }
            filter->overaction = false;
            filter->fcounter = 0;
            filter->deadtime = timenow + filter->period;
        }
        else
        {
            //check the upper limit
            if(filter->fulimit < filter->fcounter)
            {
                filter->actiontimes++;
                filter->fcounter = 0;
                filter->overaction = true;
                NetDevPostEvent(handle,filter->overevent);//post a begin message
            }
        }
    }
}
bool_t NetDevFlowCtrl(struct NetDev* handle,enNetDevFramType type)
{
    bool_t result = false;
    tagNetDevRcvFilter *filter;
    s64 timenow;
    u32 looptype;
    if(NULL != handle)
    {
        if(type < EN_NETDEV_FRAME_LAST)
        {
            filter = &handle->rfilter[type];
            if(filter->en)
            {
                filter->fcounter ++;
                filter->ftotal++;
            }
            //any data will inc the frame filter
            if(type != EN_NETDEV_FRAME_ALL   )
            {
                filter = &handle->rfilter[EN_NETDEV_FRAME_ALL   ];
                if(filter->en)
                {
                    filter->fcounter ++;
                    filter->ftotal++;
                }
            }
        }
        //check all the filter
        timenow = DjyGetSysTime();
        for(looptype =0;looptype < EN_NETDEV_FRAME_LAST;looptype++)
        {
            filter = &handle->rfilter[looptype];
            __NetDevFlowCheck(handle,filter,timenow);
        }
    }
    return result;
}


const char *pFilterItemName[EN_NETDEV_FRAME_LAST]=
{
    "BROAD",
    "POINT",
    "MULTI",
    "FRAME",
};
//we use this function to show the net device filter state
static bool_t NetDevFlowStat(char *param)
{
    bool_t      result = false;
    struct NetDev* handle;
    tagNetDevRcvFilter *filter;
    u32         type;

    handle = NetDevGet(param);
    if(NULL != handle)
    {
        printf("NETDEVFLOW:UNIT FOR CYCLE AND DEADLINE IS US\n\r");
        printf("%-6s%-3s%-3s%-3s%-9s%-9s%-9s%-9s%-9s%-9s%-9s\n\r",\
                "Name","EN","LS","US","FC","FU","FL","ACTIONS","CYCLE","DEADLINE","FT");
        for(type =0; type < EN_NETDEV_FRAME_LAST;type++)
        {
            filter = &handle->rfilter[type];
            printf("%-6s%-3s%-3s%-3s%-8x %-8x %-8x %-8x %-8x %-8llx %-8llx\n\r",\
                    pFilterItemName[type],\
                    filter->en==true?"Y":"N",\
                    filter->lackaction?"Y":"N",\
                    filter->overaction?"Y":"N",\
                    filter->fcounter,\
                    filter->fulimit,\
                    filter->fllimit,\
                    filter->actiontimes,\
                    filter->period,\
                    filter->deadtime,\
                    filter->ftotal
                    );
        }
        result =true;
    }
    return result;
}

//-----------------------------------------------------------------------------
//功能: 取网卡的私有指针
//参数: DevFace，由 NetDevInstall 返回的网卡控制块指针
//返回: true or false
//-----------------------------------------------------------------------------
void * NetDevPrivate(struct NetDev *iface)
{
    void *ret = NULL;
    if(NULL != iface)
    {
        ret = (iface)->Private;
    }
    return ret;
}

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-parameter"

//netdev shell here
//static bool_t __IfconfigShell(char *param)
bool_t ifconfig(char *param)
{
    int i = 0;
    struct NetDev *iface;
    OsPrintSplit('*',100);
    debug_printf("netdev","%-2s %-10s %-10s %-8s %-8s %-8s %-8s %-8s %-8s %-s\n\r",\
            "NO","NAME","TYPE","FUNCTION","MTU","SNDTOTAL","SNDERR","RCVTOTAL","RCVERR","MAC");
    if(mutex_lock(gIfaceCB.lock))
    {
        iface = gIfaceCB.lst;
        while(NULL != iface)
        {
            i++;
            debug_printf("netdev","%-2d %-10s %-10s %-8x %-8x %-8x %-8x %-8x %-8x %-s\n\r",\
                    i,iface->name,LinkTypeName(iface->iftype),iface->devfunc,iface->mtu,\
                    iface->pkgsnd,iface->pkgsnderr,iface->pkgrcv,iface->pkgrcverr,mac2string(iface->mac));
            iface = iface->nxt;
        }
        mutex_unlock(gIfaceCB.lock);
    }
    OsPrintSplit('*',100);
    return true;
}
#pragma GCC diagnostic pop

//-----------------------------------------------------------------------------
//功能: 网络设备接口初始化
//参数: 无
//返回: true or false
//-----------------------------------------------------------------------------
bool_t NetDevInit(void)
{
    bool_t ret = false;
    gIfaceCB.lst = NULL;
    gIfaceCB.lock = mutex_init(NULL);
    if(NULL == gIfaceCB.lock)
    {
        goto EXIT_MUTEX;
    }

    ret = true;
    return ret;


EXIT_MUTEX:
    ret = false;
    return ret;
}

ADD_TO_ROUTINE_SHELL(ifconfig,ifconfig,"usage:ifconfig");
ADD_TO_ROUTINE_SHELL(netflow,NetDevFlowStat,"usage:netflow [net card name]");
