//----------------------------------------------------
// Copyright (c) 2018, Djyos Open source Development team. All rights reserved.

// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:

// 1. Redistributions of source code must retain the above copyright notice,
//    this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright notice,
//    this list of conditions and the following disclaimer in the documentation
//    and/or other materials provided with the distribution.

// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
//-----------------------------------------------------------------------------
// Copyright (c) 2018，著作权由都江堰操作系统开源开发团队所有。著作权人保留一切权利。
//
// 这份授权条款，在使用者符合下列条件的情形下，授予使用者使用及再散播本
// 软件包装原始码及二进位可执行形式的权利，无论此包装是否经改作皆然：
//
// 1. 对于本软件源代码的再散播，必须保留上述的版权宣告、本条件列表，以
//    及下述的免责声明。
// 2. 对于本套件二进位可执行形式的再散播，必须连带以文件以及／或者其他附
//    于散播包装中的媒介方式，重制上述之版权宣告、本条件列表，以及下述
//    的免责声明。

// 免责声明：本软件是本软件版权持有人以及贡献者以现状（"as is"）提供，
// 本软件包装不负任何明示或默示之担保责任，包括但不限于就适售性以及特定目
// 的的适用性为默示性担保。版权持有人及本软件之贡献者，无论任何条件、
// 无论成因或任何责任主体、无论此责任为因合约关系、无过失责任主体或因非违
// 约之侵权（包括过失或其他原因等）而起，对于任何因使用本软件包装所产生的
// 任何直接性、间接性、偶发性、特殊性、惩罚性或任何结果的损害（包括但不限
// 于替代商品或劳务之购用、使用损失、资料损失、利益损失、业务中断等等），
// 不负任何责任，即在该种使用已获事前告知可能会造成此类损害的情形下亦然。
//-----------------------------------------------------------------------------
//所属模块:标准输入--触摸屏模块

//------------------------------------------------------

#include "stdint.h"
#include "stdio.h"
#include "stddef.h"
#include "iicbus.h"
#include "systime.h"
//#include "sys_delay.h"
#include "board.h"
#include "project_config.h"     //本文件由IDE中配置界面生成，存放在APP的工程目录中。
                                //允许是个空文件，所有配置将按默认值配置。

//@#$%component configure   ****组件配置开始，用于 DIDE 中图形化配置界面
//****配置块的语法和使用方法，参见源码根目录下的文件：component_config_readme.txt****
//%$#@initcode      ****初始化代码开始，由 DIDE 删除“//”后copy到初始化文件中
////    不在initprj调用 OV2640_Init，而是在摄像头应用中调用
//%$#@end initcode  ****初始化代码结束

//%$#@describe      ****组件描述开始
//component name:"camera_ov2640"//摄像头
//parent:"none"                 //填写该组件的父组件名字，none表示没有父组件
//attribute:bsp                 //选填“third、system、bsp、user”，本属性用于在IDE中分组
//select:choosable              //选填“required、choosable、none”，若填必选且需要配置参数，则IDE裁剪界面中默认勾取，
                                //不可取消，必选且不需要配置参数的，或是不可选的，IDE裁剪界面中不显示，
//init time:later               //初始化时机，可选值：early，medium，later, pre-main。
                                //表示初始化时间，分别是早期、中期、后期
//dependence:"none"            //该组件的依赖组件名（可以是none，表示无依赖组件），
                                //选中该组件时，被依赖组件将强制选中，
                                //如果依赖多个组件，则依次列出，用“,”分隔
//weakdependence:"none"          //该组件的弱依赖组件名（可以是none，表示无依赖组件），
                                //选中该组件时，被依赖组件不会被强制选中，
                                //如果依赖多个组件，则依次列出，用“,”分隔
//mutex:"none"                  //该组件的互斥组件名（可以是none，表示无互斥组件），
                                //如果与多个组件互斥，则依次列出，用“,”分隔
//%$#@end describe  ****组件描述结束

//%$#@configue      ****参数配置开始
#if ( CFG_MODULE_ENABLE_CAMERA_OV2640 == false )
//#warning  " camera_ov2640  组件参数未配置，使用默认配置"
//%$#@target = header           //header = 生成头文件,cmdline = 命令行变量，DJYOS自有模块禁用
#define CFG_MODULE_ENABLE_CAMERA_OV2640    false //如果勾选了本组件，将由DIDE在project_config.h或命令行中定义为true
//%$#@enum,true,false,
//%$#@string,1,128,
#define CFG_OV2640_BUS_NAME     "IoIic"        //"IIC总线名称",触摸芯片使用的IIC总线名称
//%$#@select,        ***从列出的选项中选择若干个定义成宏
//%$#@free,
#endif
//%$#@end configue  ****参数配置结束
//@#$%component end configure

#define uint8_t unsigned char
#define delay_ms(x) DJY_DelayUs(x * 1000)

struct OV_RegValue
{
    u8   u8RegAddr;          //Register Address
    u8   u8Value;            //Register Data
};

#define _REG_TABLE_SIZE(nTableName) (sizeof(nTableName)/sizeof(struct OV_RegValue))

struct OV_RegValue g_sOV2640_RegValue[] =
#if 1
{
/* 640x480 */
#define UXGA  1
{0xff, 0x01},{0x12, 0x80},      //reset
{0xff, 0x00},{0x2c, 0xff},{0x2e, 0xdf},     //dont know
{0xff, 0x01},     //dsp
{0x3c, 0x32},     //dont know
{0x11, 0x00},       //时钟
{0x09, 0x02},       //控制

//0x04 设置上下左右翻转 Bit[7]:Horizontal mirror    Bit[6]:Vertical flip
//{0x04, 0xD8},//设置方向
//{0x04, 0xA8},//设置方向
{0x04, 0x58},//设置方向
{0x13, 0xe5},{0x14, 0x48},  //控制
{0x2c, 0x0c},{0x33, 0x78},{0x3a, 0x33},{0x3b, 0xfb},{0x3e, 0x00},{0x43, 0x11},        //dont know
{0x16, 0x10},{0x39, 0x02},{0x35, 0x88},{0x22, 0x0a},{0x37, 0x40},{0x23, 0x00},        //dont know
{0x34, 0xa0},   //zoom window horizontal start point
{0x36, 0x1a},{0x06, 0x02},          //dont know
{0x07, 0xc0},{0x0d, 0xb7},{0x0e, 0x01},{0x4c, 0x00},{0x4a, 0x81},{0x21, 0x99},        //dont know
{0x24, 0x3a},{0x25, 0x32},          //亮度
{0x26, 0x82},                       //fast mode 大步阈值
{0x5c, 0x00},{0x63, 0x00},        //dont know
{0x5d, 0x55},{0x5e, 0x7d},{0x5f, 0x7d},{0x60, 0x55},    //AVGsel
{0x61, 0x70},{0x62, 0x80},      //直方图算法
{0x7c, 0x05},        //dont know
{0x20, 0x80},{0x28, 0x30},{0x6c, 0x00},{0x6d, 0x80},{0x6e, 0x00},{0x70, 0x02},{0x71, 0x94},{0x73, 0xc1},{0x3d, 0x34},       //dont know
{0x5a, 0x57},        //dont know
{0x4f, 0xbb},{0x50, 0x9c},  //50/60hz频段AEC

{0xff, 0x00},       //sensor
{0xe5, 0x7f},       //dont know
{0xf9, 0xc0},       //sensor reset
{0x41, 0x24},        //dont know
{0xe0, 0x14},       //reset
{0x76, 0xff},       //dont know
{0x33, 0xa0},{0x42, 0x20},{0x43, 0x18},{0x4c, 0x00},        //dont know
{0x87, 0xd0},       //module enable
{0x88, 0x3f},{0xd7, 0x03},{0xd9, 0x10},        //dont know
{0xd3, 0x82},       //自动模式，DVP时钟
{0xc8, 0x08},{0xc9, 0x80},        //dont know
{0x7c, 0x00},      //SDE address
{0x7d, 0x02},      //SDE data
{0x7c, 0x03},      //SDE address
{0x7d, 0x48},{0x7d, 0x48},
{0x7c, 0x08},      //SDE address
{0x7d, 0x20},{0x7d, 0x10},{0x7d, 0x0e},      //SDE data
{0x90, 0x00},       //dont know
{0x91, 0x0e},{0x91, 0x1a},{0x91, 0x31},{0x91, 0x5a},{0x91, 0x69},{0x91, 0x75},       //dont know
{0x91, 0x7e},{0x91, 0x88},{0x91, 0x8f},{0x91, 0x96},{0x91, 0xa3},{0x91, 0xaf},       //dont know
{0x91, 0xc4},{0x91, 0xd7},{0x91, 0xe8},{0x91, 0x20},       //dont know
{0x92, 0x00},       //dont know
{0x93, 0x06},{0x93, 0xe3},{0x93, 0x05},{0x93, 0x05},{0x93, 0x00},{0x93, 0x02},       //dont know
{0x93, 0x00},{0x93, 0x00},{0x93, 0x00},{0x93, 0x00},{0x93, 0x00},{0x93, 0x00},{0x93, 0x00},       //dont know
{0x96, 0x00},       //dont know
{0x97, 0x08},{0x97, 0x19},{0x97, 0x02},{0x97, 0x0c},{0x97, 0x24},{0x97, 0x30},       //dont know
{0x97, 0x28},{0x97, 0x26},{0x97, 0x02},{0x97, 0x98},{0x97, 0x80},{0x97, 0x00},{0x97, 0x00},       //dont know
{0xc3, 0xed},   //module enable
{0xa4, 0x00},{0xa8, 0x00},{0xc5, 0x11},{0xc6, 0x51},{0xbf, 0x80},{0xc7, 0x10},       //dont know
{0xb6, 0x66},{0xb8, 0xa5},{0xb7, 0x64},{0xb9, 0x7c},{0xb3, 0xaf},{0xb4, 0x97},       //dont know
{0xb5, 0xff},{0xb0, 0xc5},{0xb1, 0x94},{0xb2, 0x0f},{0xc4, 0x5c},       //dont know
{0xff, 0x01},       //dsp
{0x11, 0x00},       //倍频开关关闭
{0xff, 0x01},       //dsp
#if UXGA == 1
{0x12, 0x00},       //Ctrl，select uxga mode
#else
{0x12, 0x40},       //Ctrl，select Svga mode
#endif
#if UXGA == 1
{0x17, 0x11}, {0x18, 75},      //horizontal window start and end,75 for uxga ,43 for svga****sensor cut，svga
{0x19, 0x01},{0x1a, 0x97},      //vertical window start and end,01/97 for uxga ,00/4b for svga
{0x32, 0x36},       //17/18的补充，36 for uxga ,09 for svga
#else
{0x17, 0x11}, {0x18, 0x43},      //horizontal window start and end,75 for uxga ,43 for svga****sensor cut，svga-y
{0x19, 0x00},{0x1a, 0x4b},      //vertical window start and end,01/97 for uxga ,00/4b for svga
{0x32, 0x09},       //17/18的补充，36 for uxga ,09 for svga
#endif

{0xff,0x00},
#if UXGA == 1
{0xc0, 0xc8},{0xc1, 0x96},       //image size [10:3] 200*8=1600-------------zoom out：1200-y
#else
{0xc0, 0x64},{0xc1, 0x4b},{0x8c, 0x00}, // Xiao: H 0x64*8 = 800, V 0x4B*8 = 600-------zoom out：800*600
#endif
{0x86, 0x1d},       //module enable
{0x50, 0x00},       //Ctrl
#if UXGA == 1
{0x51, 0x90},{0x52, 0x2c}, //H_SIZE 7:0，real/4 V_SIZE 7:0，real/4 +++++2nd cut 1600*1200
#else
{0x51, 0x90},{0x52, 0x18}, //H_SIZE 7:0，real/4 V_SIZE 7:0，real/4 +++++2nd cut 1600*1120-y
#endif
{0x53, 0x00},{0x54, 0x00},       //OFFSET_X 7:0,OFFSET_Y 7:0
{0x55, 0x88},       //V_SIZE8，OFFSET_Y 10:8，H_SIZE8，OFFSET_X 10:8
{0x57, 0x00},       //H_SIZE9
#if UXGA == 1
{0x5a, 0x90},{0x5b, 0x2c},       //OUTW[7:0],OUTH[7:0]，real/4==============OUTwin 1600*1200
{0x5c, 0x05},       //ZMSPD,OUTH8,OUTW[9:8]
#else
{0x5a, 0xA0},{0x5b, 0x78}, // Xiao: ZW 0xa0(160)*4 = 640, ZH 0x78(120)*4 = 480===outwin 640*480
{0x5c, 0x00},       //ZMSPD,OUTH8,OUTW[9:8]
#endif
{0xd3, 0x04},       //非自动模式，DVP时钟

//#if UXGA == 1
//{0x5a, 0x90},{0x5b, 0x2c},       //OUTW[7:0],OUTH[7:0]，real/4==============OUTwin 1600*1200
//#else
//{0x5a, 0x90},{0x5b, 0x18},       //OUTW[7:0],OUTH[7:0]，real/4==============OUTwin 1600*1120-y
//#endif
//{0x5c, 0x05},       //ZMSPD,OUTH8,OUTW[9:8]
{0xc3, 0xed},       //module enable
{0x7f, 0x00},       //dont know
//{0xda, 0x04},       //image output format,
{0xe5, 0x1f},{0xe1, 0x67},       //dont know
{0xe0, 0x00},       //complete reset
{0xdd, 0xff},       //dont know
{0x05, 0x00},       //enable dsp

{0xff, 0x01},
{0x4f, 0xca},{0x50, 0xa8},      //50/60hz频段AEC
{0x5a, 0x23},{0x6d, 0x00},       //dont know
{0x3d, 0x38},{0x39, 0x12},{0x35, 0xda},{0x22, 0x1a},{0x37, 0xc3},{0x23, 0x00},       //dont know
{0x34, 0xc0},       //dont know,zoom window start
{0x36, 0x1a},{0x06, 0x88},       //dont know
{0x07, 0xc0},{0x0d, 0x87},{0x0e, 0x41},       //dont know
{0x4c, 0x00},       //dont know
{0x48, 0x00},       //zoom veritical window 补充
{0x5B, 0x00},{0x42, 0x03},       //dont know

//{0xff, 0x00},       //sensor
//{0xe0, 0x04},       //reset module
//#if UXGA == 1
//{0xc0, 0xc8},{0xc1, 0x96},{0x8c, 0x00}, // Xiao: H 0xc8*8 = 1600, V 0x96*8 = 1200---------zoom out：1600*1200
//#else
//{0xc0, 0x64},{0xc1, 0x4B},{0x8c, 0x00}, // Xiao: H 0x64*8 = 800, V 0x4B*8 = 600------zoom out：800*600
//#endif
//{0x86, 0x1D},       //module enable
//{0xd3, 0x82},{0xe0, 0x00},       //自动模式，DVP时钟，复位完成
//
//{0xff, 0x00},       //sensor
//#if UXGA == 1
//{0xc0, 0xc8},{0xc1, 0x96},{0x8c, 0x00}, // Xiao: H 0xc8*8 = 1600, V 0x96*8 = 1200---------zoom out：1600*1200
//#else
//{0xc0, 0x64},{0xc1, 0x4B},{0x8c, 0x00}, // Xiao: H 0x64*8 = 800, V 0x4B*8 = 600---------zoom out：800*600
//#endif
//{0x86, 0x3D},       //module enable
//
//{0x50, 0x00},       //ctrl
//#if UXGA == 1
//{0x51, 0x90},{0x52, 0x2c}, //H_SIZE 7:0，real/4 V_SIZE 7:0，real/4 +++++2nd cut 1600*1200
//{0x53, 0x00},{0x54, 0x00},       //OFFSET_X 7:0,OFFSET_Y 7:0
//{0x55, 0x88},       //V_SIZE8，OFFSET_Y 10:8，H_SIZE8，OFFSET_X 10:8
//#else
//{0x51, 0xC8},{0x52, 0x96}, //H_SIZE 7:0，real/4 V_SIZE 7:0，real/4 +++++2nd cut 800*600
//{0x53, 0x00},{0x54, 0x00},       //OFFSET_X 7:0,OFFSET_Y 7:0
//{0x55, 0x00},       //V_SIZE8，OFFSET_Y 10:8，H_SIZE8，OFFSET_X 10:8
//#endif
//{0x57, 0x00},       //H_SIZE9
//
//#if UXGA == 1
//{0x5a, 0x90},{0x5b, 0x2c},       //OUTW[7:0],OUTH[7:0]，real/4==============OUTwin 1600*1200
//{0x5c, 0x05},       //ZMSPD,OUTH8,OUTW[9:8]
//#else
//{0x5a, 0xA0},{0x5b, 0x78}, // Xiao: ZW 0xa0(160)*4 = 640, ZH 0x78(120)*4 = 480===outwin 640*480
//{0x5c, 0x00},       //ZMSPD,OUTH8,OUTW[9:8]
//#endif
//{0xd3, 0x04},       //非自动模式，DVP时钟

{0xFF, 0x00},       //sensor
{0xE0, 0x04},       //reset module
{0xE1, 0x67},{0xD7, 0x01},       //dont know
{0xDA, 0x00},       //image output format,
{0xD3, 0x82},{0xE0, 0x00},       //自动模式，DVP时钟，复位完成
{0xFF, 0xFF}
};
#else
{
/* 640x480 */
{0xff, 0x01},{0x12, 0x80},      //reset
{0xff, 0x00},{0x2c, 0xff},{0x2e, 0xdf},
{0xff, 0x01},{0x3c, 0x32},{0x11, 0x00},{0x09, 0x02},

//0x04 设置上下左右翻转 Bit[7]:Horizontal mirror    Bit[6]:Vertical flip
//{0x04, 0xD8},//设置方向
//{0x04, 0xA8},//设置方向
{0x04, 0x58},//设置方向
{0x13, 0xe5},{0x14, 0x48},{0x2c, 0x0c},{0x33, 0x78},{0x3a, 0x33},{0x3b, 0xfb},{0x3e, 0x00},{0x43, 0x11},
{0x16, 0x10},{0x39, 0x02},{0x35, 0x88},{0x22, 0x0a},{0x37, 0x40},{0x23, 0x00},{0x34, 0xa0},{0x36, 0x1a},{0x06, 0x02},
{0x07, 0xc0},{0x0d, 0xb7},{0x0e, 0x01},{0x4c, 0x00},{0x4a, 0x81},{0x21, 0x99},{0x24, 0x3a},{0x25, 0x32},{0x26, 0x82},
{0x5c, 0x00},{0x63, 0x00},{0x5d, 0x55},{0x5e, 0x7d},{0x5f, 0x7d},{0x60, 0x55},{0x61, 0x70},{0x62, 0x80},{0x7c, 0x05},
{0x20, 0x80},{0x28, 0x30},{0x6c, 0x00},{0x6d, 0x80},{0x6e, 0x00},{0x70, 0x02},{0x71, 0x94},{0x73, 0xc1},{0x3d, 0x34},
{0x5a, 0x57},{0x4f, 0xbb},{0x50, 0x9c},

{0xff, 0x00},{0xe5, 0x7f},{0xf9, 0xc0},{0x41, 0x24},{0xe0, 0x14},{0x76, 0xff},
{0x33, 0xa0},{0x42, 0x20},{0x43, 0x18},{0x4c, 0x00},{0x87, 0xd0},{0x88, 0x3f},{0xd7, 0x03},{0xd9, 0x10},{0xd3, 0x82},
{0xc8, 0x08},{0xc9, 0x80},{0x7c, 0x00},{0x7d, 0x02},{0x7c, 0x03},{0x7d, 0x48},{0x7d, 0x48},{0x7c, 0x08},{0x7d, 0x20},
{0x7d, 0x10},{0x7d, 0x0e},{0x90, 0x00},{0x91, 0x0e},{0x91, 0x1a},{0x91, 0x31},{0x91, 0x5a},{0x91, 0x69},{0x91, 0x75},
{0x91, 0x7e},{0x91, 0x88},{0x91, 0x8f},{0x91, 0x96},{0x91, 0xa3},{0x91, 0xaf},{0x91, 0xc4},{0x91, 0xd7},{0x91, 0xe8},
{0x91, 0x20},{0x92, 0x00},{0x93, 0x06},{0x93, 0xe3},{0x93, 0x05},{0x93, 0x05},{0x93, 0x00},{0x93, 0x02},{0x93, 0x00},
{0x93, 0x00},{0x93, 0x00},{0x93, 0x00},{0x93, 0x00},{0x93, 0x00},{0x93, 0x00},{0x96, 0x00},{0x97, 0x08},{0x97, 0x19},
{0x97, 0x02},{0x97, 0x0c},{0x97, 0x24},{0x97, 0x30},{0x97, 0x28},{0x97, 0x26},{0x97, 0x02},{0x97, 0x98},{0x97, 0x80},
{0x97, 0x00},{0x97, 0x00},{0xc3, 0xed},{0xa4, 0x00},{0xa8, 0x00},{0xc5, 0x11},{0xc6, 0x51},{0xbf, 0x80},{0xc7, 0x10},
{0xb6, 0x66},{0xb8, 0xa5},{0xb7, 0x64},{0xb9, 0x7c},{0xb3, 0xaf},{0xb4, 0x97},{0xb5, 0xff},{0xb0, 0xc5},{0xb1, 0x94},
{0xb2, 0x0f},{0xc4, 0x5c},{0xc0, 0xc8},{0xc1, 0x96},{0x86, 0x1d},{0x50, 0x00},{0x51, 0x90},{0x52, 0x18},{0x53, 0x00},
{0x54, 0x00},{0x55, 0x88},{0x57, 0x00},{0x5a, 0x90},{0x5b, 0x18},{0x5c, 0x05},{0xc3, 0xed},{0x7f, 0x00},{0xda, 0x04},
{0xe5, 0x1f},{0xe1, 0x67},{0xe0, 0x00},{0xdd, 0xff},{0x05, 0x00},

{0xff, 0x01},{0x11, 0x00},
{0xff, 0x01},{0x12, 0x40},
{0x17, 0x11},{0x18, 0x43},{0x19, 0x00},{0x1a, 0x4b},{0x32, 0x09},{0x4f, 0xca},{0x50, 0xa8},{0x5a, 0x23},{0x6d, 0x00},
{0x3d, 0x38},{0x39, 0x12},{0x35, 0xda},{0x22, 0x1a},{0x37, 0xc3},{0x23, 0x00},{0x34, 0xc0},{0x36, 0x1a},{0x06, 0x88},
{0x07, 0xc0},{0x0d, 0x87},{0x0e, 0x41},{0x4c, 0x00},{0x48, 0x00},{0x5B, 0x00},{0x42, 0x03},
{0xff, 0x00},{0xe0, 0x04},
{0xc0, 0x64},{0xc1, 0x4B},{0x8c, 0x00}, // Xiao: H 0x64*8 = 800, V 0x4B*8 = 600
{0x86, 0x1D},
{0xd3, 0x82},{0xe0, 0x00},
{0xff, 0x00},
{0xc0, 0x64},{0xc1, 0x4B},{0x8c, 0x00}, // Xiao: H 0x64*8 = 800, V 0x4B*8 = 600
{0x86, 0x3D},
{0x50, 0x00},
{0x51, 0xC8},{0x52, 0x96},{0x53, 0x00},{0x54, 0x00},{0x55, 0x00}, // Xiao: H 0xC8(200)*4 = 800, V 0x96(150)*4 = 600
{0x5a, 0xA0},{0x5b, 0x78},{0x5c, 0x00}, // Xiao: ZW 0xa0(160)*4 = 640, ZH 0x78(120)*4 = 480
{0xd3, 0x04},
{0xFF, 0x00},{0xE0, 0x04},{0xE1, 0x67},{0xD7, 0x01},{0xDA, 0x00},{0xD3, 0x82},{0xE0, 0x00},
{0xFF, 0xFF}
};
#endif

//struct OV_RegValue g_sOV2640_RegValue[] =
//{
///* 640x480 */
//{0xff, 0x01},{0x12, 0x80},
//{0xff, 0x00},{0x2c, 0xff},{0x2e, 0xdf},
//{0xff, 0x01},{0x3c, 0x32},{0x11, 0x00},{0x09, 0x02},
//
//////0x04 设置上下左右翻转 Bit[7]:Horizontal mirror    Bit[6]:Vertical flip??
//{0x04, 0xA8},{0x13, 0xe5},{0x14, 0x48},{0x2c, 0x0c},{0x33, 0x78},{0x3a, 0x33},{0x3b, 0xfb},{0x3e, 0x00},{0x43, 0x11},
//{0x16, 0x10},{0x39, 0x02},{0x35, 0x88},{0x22, 0x0a},{0x37, 0x40},{0x23, 0x00},{0x34, 0xa0},{0x36, 0x1a},{0x06, 0x02},
//{0x07, 0xc0},{0x0d, 0xb7},{0x0e, 0x01},{0x4c, 0x00},{0x4a, 0x81},{0x21, 0x99},{0x24, 0x3a},{0x25, 0x32},{0x26, 0x82},
//{0x5c, 0x00},{0x63, 0x00},{0x5d, 0x55},{0x5e, 0x7d},{0x5f, 0x7d},{0x60, 0x55},{0x61, 0x70},{0x62, 0x80},{0x7c, 0x05},
//{0x20, 0x80},{0x28, 0x30},{0x6c, 0x00},{0x6d, 0x80},{0x6e, 0x00},{0x70, 0x02},{0x71, 0x94},{0x73, 0xc1},{0x3d, 0x34},
//{0x5a, 0x57},{0x4f, 0xbb},{0x50, 0x9c},
//
//{0xff, 0x00},{0xe5, 0x7f},{0xf9, 0xc0},{0x41, 0x24},{0xe0, 0x14},{0x76, 0xff},
//{0x33, 0xa0},{0x42, 0x20},{0x43, 0x18},{0x4c, 0x00},{0x87, 0xd0},{0x88, 0x3f},{0xd7, 0x03},{0xd9, 0x10},{0xd3, 0x82},
//{0xc8, 0x08},{0xc9, 0x80},{0x7c, 0x00},{0x7d, 0x02},{0x7c, 0x03},{0x7d, 0x48},{0x7d, 0x48},{0x7c, 0x08},{0x7d, 0x20},
//{0x7d, 0x10},{0x7d, 0x0e},{0x90, 0x00},{0x91, 0x0e},{0x91, 0x1a},{0x91, 0x31},{0x91, 0x5a},{0x91, 0x69},{0x91, 0x75},
//{0x91, 0x7e},{0x91, 0x88},{0x91, 0x8f},{0x91, 0x96},{0x91, 0xa3},{0x91, 0xaf},{0x91, 0xc4},{0x91, 0xd7},{0x91, 0xe8},
//{0x91, 0x20},{0x92, 0x00},{0x93, 0x06},{0x93, 0xe3},{0x93, 0x05},{0x93, 0x05},{0x93, 0x00},{0x93, 0x02},{0x93, 0x00},
//{0x93, 0x00},{0x93, 0x00},{0x93, 0x00},{0x93, 0x00},{0x93, 0x00},{0x93, 0x00},{0x96, 0x00},{0x97, 0x08},{0x97, 0x19},
//{0x97, 0x02},{0x97, 0x0c},{0x97, 0x24},{0x97, 0x30},{0x97, 0x28},{0x97, 0x26},{0x97, 0x02},{0x97, 0x98},{0x97, 0x80},
//{0x97, 0x00},{0x97, 0x00},{0xc3, 0xed},{0xa4, 0x00},{0xa8, 0x00},{0xc5, 0x11},{0xc6, 0x51},{0xbf, 0x80},{0xc7, 0x10},
//{0xb6, 0x66},{0xb8, 0xa5},{0xb7, 0x64},{0xb9, 0x7c},{0xb3, 0xaf},{0xb4, 0x97},{0xb5, 0xff},{0xb0, 0xc5},{0xb1, 0x94},
//{0xb2, 0x0f},{0xc4, 0x5c},{0xc0, 0xc8},{0xc1, 0x96},{0x86, 0x1d},{0x50, 0x00},{0x51, 0x90},{0x52, 0x18},{0x53, 0x00},
//{0x54, 0x00},{0x55, 0x88},{0x57, 0x00},{0x5a, 0x90},{0x5b, 0x18},{0x5c, 0x05},{0xc3, 0xed},{0x7f, 0x00},{0xda, 0x04},
//{0xe5, 0x1f},{0xe1, 0x67},{0xe0, 0x00},{0xdd, 0xff},{0x05, 0x00},
//{0xff, 0x01},{0x11, 0x01},
//{0xff, 0x01},{0x12, 0x40},
//{0x17, 0x11},{0x18, 0x43},{0x19, 0x00},{0x1a, 0x4b},{0x32, 0x09},{0x4f, 0xca},{0x50, 0xa8},{0x5a, 0x23},{0x6d, 0x00},
//{0x3d, 0x38},{0x39, 0x12},{0x35, 0xda},{0x22, 0x1a},{0x37, 0xc3},{0x23, 0x00},{0x34, 0xc0},{0x36, 0x1a},{0x06, 0x88},
//{0x07, 0xc0},{0x0d, 0x87},{0x0e, 0x41},{0x4c, 0x00},{0x48, 0x00},{0x5B, 0x00},{0x42, 0x03},
//{0xff, 0x00},{0xe0, 0x04},
//{0xc0, 0x64},{0xc1, 0x4B},{0x8c, 0x00}, // Xiao: H 0x64*8 = 800, V 0x4B*8 = 600
//{0x86, 0x1D},
//{0xd3, 0x82},{0xe0, 0x00},
//{0xff, 0x00},
//{0xc0, 0x64},{0xc1, 0x4B},{0x8c, 0x00}, // Xiao: H 0x64*8 = 800, V 0x4B*8 = 600
//{0x86, 0x3D},
//{0x50, 0x00},
//{0x51, 0xC8},{0x52, 0x96},{0x53, 0x00},{0x54, 0x00},{0x55, 0x00}, // Xiao: H 0xC8(200)*4 = 800, V 0x96(150)*4 = 600
//{0x5a, 0xA0},{0x5b, 0x78},{0x5c, 0x00}, // Xiao: ZW 0xa0(160)*4 = 640, ZH 0x78(120)*4 = 480
//{0xd3, 0x04},
//{0xFF, 0x00},{0xE0, 0x04},{0xE1, 0x67},{0xD7, 0x01},{0xDA, 0x00},{0xD3, 0x82},{0xE0, 0x00},
//{0xFF, 0xFF}
//};
typedef struct
{
    uint8_t Manufacturer_ID1;
    uint8_t Manufacturer_ID2;
    uint8_t PIDH;
    uint8_t PIDL;
} OV2640_IDTypeDef;

#define TWI                 0
#define SCCB_ADDR           0x60
#define OV2640_ADDR_BITS    8
static struct IIC_Device    *ps_OV2640_Dev = NULL;
#define sysprintf printf

int OV2640_WriteReg(u8 uRegAddr, u8 uData)
{
    IIC_Write(ps_OV2640_Dev, uRegAddr, &uData, 1, true, CN_TIMEOUT_FOREVER);
    return 0;
}

u8 OV2640_ReadReg(u8 uRegAddr)
{
    u8 u8Data;
    IIC_Read(ps_OV2640_Dev, uRegAddr, &u8Data, 1, CN_TIMEOUT_FOREVER);
    return u8Data;
}

void write_SCCB(u8 uRegAddr, u8 uData)
{
    IIC_Write(ps_OV2640_Dev, uRegAddr, &uData, 1, true, CN_TIMEOUT_FOREVER);
}
void ov2640_SvgaPreview(void)
{
    // OV2640_SVGA_YUV_AM 14.3 fps
    // 24 MHz input clock
    //
    //
    write_SCCB(0xff, 0x01);
    write_SCCB(0x12, 0x80);
    DJY_EventDelay(1000);
    write_SCCB(0xff, 0x00);
    write_SCCB(0x2c, 0xff);
    write_SCCB(0x2e, 0xdf);
    write_SCCB(0xff, 0x01);
    write_SCCB(0x3c, 0x32);
    //
    write_SCCB(0x11, 0x01);
    write_SCCB(0x09, 0x02);
    write_SCCB(0x04, 0x28);
    write_SCCB(0x13, 0xe5);
    write_SCCB(0x14, 0x48);
    write_SCCB(0x2c, 0x0c);
    write_SCCB(0x33, 0x78);
    write_SCCB(0x3a, 0x33);
    write_SCCB(0x3b, 0xfB);
    //
    write_SCCB(0x3e, 0x00);
    write_SCCB(0x43, 0x11);
    write_SCCB(0x16, 0x10);
    //
    write_SCCB(0x39, 0x92);
    //
    write_SCCB(0x35, 0xda);
    write_SCCB(0x22, 0x1a);
    write_SCCB(0x37, 0xc3);
    write_SCCB(0x23, 0x00);
    write_SCCB(0x34, 0xc0);
    write_SCCB(0x36, 0x1a);
    write_SCCB(0x06, 0x88);
    write_SCCB(0x07, 0xc0);
    write_SCCB(0x0d, 0x87);
    write_SCCB(0x0e, 0x41);
    write_SCCB(0x4c, 0x00);
    write_SCCB(0x48, 0x00);
    write_SCCB(0x5B, 0x00);
    write_SCCB(0x42, 0x03);
    //
    write_SCCB(0x4a, 0x81);
    write_SCCB(0x21, 0x99);
    //
    write_SCCB(0x24, 0x40);
    write_SCCB(0x25, 0x38);
    write_SCCB(0x26, 0x82);
    write_SCCB(0x5c, 0x00);
    write_SCCB(0x63, 0x00);
    write_SCCB(0x61, 0x70);
    write_SCCB(0x62, 0x80);
    write_SCCB(0x7c, 0x05);
    //
    write_SCCB(0x20, 0x80);
    write_SCCB(0x28, 0x30);
    write_SCCB(0x6c, 0x00);
    write_SCCB(0x6d, 0x80);
    write_SCCB(0x6e, 0x00);
    write_SCCB(0x70, 0x02);
    write_SCCB(0x71, 0x94);
    write_SCCB(0x73, 0xc1);
    //
    write_SCCB(0x12, 0x40);
    write_SCCB(0x17, 0x11);
    write_SCCB(0x18, 0x43);
    write_SCCB(0x19, 0x00);
    write_SCCB(0x1a, 0x4b);
    write_SCCB(0x32, 0x09);
    write_SCCB(0x37, 0xc0);
    write_SCCB(0x4f, 0x60);
    write_SCCB(0x50, 0xa8);
    write_SCCB(0x6d, 0x00);
    write_SCCB(0x3d, 0x38);
    //
    write_SCCB(0x46, 0x3f);
    write_SCCB(0x4f, 0x60);
    write_SCCB(0x0c, 0x3c);
    //
    write_SCCB(0xff, 0x00);
    write_SCCB(0xe5, 0x7f);
    write_SCCB(0xf9, 0xc0);
    write_SCCB(0x41, 0x24);
    write_SCCB(0xe0, 0x14);
    write_SCCB(0x76, 0xff);
    write_SCCB(0x33, 0xa0);
    write_SCCB(0x42, 0x20);
    write_SCCB(0x43, 0x18);
    write_SCCB(0x4c, 0x00);
    write_SCCB(0x87, 0xd5);
    write_SCCB(0x88, 0x3f);
    write_SCCB(0xd7, 0x03);
    write_SCCB(0xd9, 0x10);
    write_SCCB(0xd3, 0x82);
    //
    write_SCCB(0xc8, 0x08);
    write_SCCB(0xc9, 0x80);
    //
    write_SCCB(0x7c, 0x00);
    write_SCCB(0x7d, 0x00);
    write_SCCB(0x7c, 0x03);
    write_SCCB(0x7d, 0x48);
    write_SCCB(0x7d, 0x48);
    write_SCCB(0x7c, 0x08);
    write_SCCB(0x7d, 0x20);
    write_SCCB(0x7d, 0x10);
    write_SCCB(0x7d, 0x0e);
    //
    write_SCCB(0x90, 0x00);
    write_SCCB(0x91, 0x0e);
    write_SCCB(0x91, 0x1a);
    write_SCCB(0x91, 0x31);
    write_SCCB(0x91, 0x5a);
    write_SCCB(0x91, 0x69);
    write_SCCB(0x91, 0x75);
    write_SCCB(0x91, 0x7e);
    write_SCCB(0x91, 0x88);
    write_SCCB(0x91, 0x8f);
    write_SCCB(0x91, 0x96);
    write_SCCB(0x91, 0xa3);
    write_SCCB(0x91, 0xaf);
    write_SCCB(0x91, 0xc4);
    write_SCCB(0x91, 0xd7);
    write_SCCB(0x91, 0xe8);
    write_SCCB(0x91, 0x20);
    //
    write_SCCB(0x92, 0x00);
    write_SCCB(0x93, 0x06);
    write_SCCB(0x93, 0xe3);
    write_SCCB(0x93, 0x05);
    write_SCCB(0x93, 0x05);
    write_SCCB(0x93, 0x00);
    write_SCCB(0x93, 0x04);
    write_SCCB(0x93, 0x00);
    write_SCCB(0x93, 0x00);
    write_SCCB(0x93, 0x00);
    write_SCCB(0x93, 0x00);
    write_SCCB(0x93, 0x00);
    write_SCCB(0x93, 0x00);
    write_SCCB(0x93, 0x00);
    //
    write_SCCB(0x96, 0x00);
    write_SCCB(0x97, 0x08);
    write_SCCB(0x97, 0x19);
    write_SCCB(0x97, 0x02);
    write_SCCB(0x97, 0x0c);
    write_SCCB(0x97, 0x24);
    write_SCCB(0x97, 0x30);
    write_SCCB(0x97, 0x28);
    write_SCCB(0x97, 0x26);
    write_SCCB(0x97, 0x02);
    write_SCCB(0x97, 0x98);
    write_SCCB(0x97, 0x80);
    write_SCCB(0x97, 0x00);
    write_SCCB(0x97, 0x00);
    //
    write_SCCB(0xc3, 0xed);
    write_SCCB(0xa4, 0x00);
    write_SCCB(0xa8, 0x00);
    write_SCCB(0xc5, 0x11);
    write_SCCB(0xc6, 0x51);
    write_SCCB(0xbf, 0x80);
    write_SCCB(0xc7, 0x10);
    write_SCCB(0xb6, 0x66);
    write_SCCB(0xb8, 0xA5);
    write_SCCB(0xb7, 0x64);
    write_SCCB(0xb9, 0x7C);
    write_SCCB(0xb3, 0xaf);
    write_SCCB(0xb4, 0x97);
    write_SCCB(0xb5, 0xFF);
    write_SCCB(0xb0, 0xC5);
    write_SCCB(0xb1, 0x94);
    write_SCCB(0xb2, 0x0f);
    write_SCCB(0xc4, 0x5c);
    //
    write_SCCB(0xc0, 0x64);
    write_SCCB(0xc1, 0x4B);
    write_SCCB(0x8c, 0x00);
    write_SCCB(0x86, 0x3D);
    write_SCCB(0x50, 0x00);
    write_SCCB(0x51, 0xC8);
    write_SCCB(0x52, 0x96);
    write_SCCB(0x53, 0x00);
    write_SCCB(0x54, 0x00);
    write_SCCB(0x55, 0x00);
    write_SCCB(0x5a, 0xC8);
    write_SCCB(0x5b, 0x96);
    write_SCCB(0x5c, 0x00);
    write_SCCB(0xd3, 0x82);
    //
    write_SCCB(0xc3, 0xed);
    write_SCCB(0x7f, 0x00);
    //
    write_SCCB(0xda, 0x00);
    //
    write_SCCB(0xe5, 0x1f);
    write_SCCB(0xe1, 0x67);
    write_SCCB(0xe0, 0x00);
    write_SCCB(0xdd, 0x7f);
    write_SCCB(0x05, 0x00);
}
void ov2640_UxgaCapture(void)
{
    write_SCCB(0xff, 0x01);
    write_SCCB(0x12, 0x80);
    DJY_EventDelay(1000);
    write_SCCB(0xff, 0x00);
    write_SCCB(0x2c, 0xff);
    write_SCCB(0x2e, 0xdf);
    write_SCCB(0xff, 0x01);
    write_SCCB(0x3c, 0x32);
    //
    write_SCCB(0x11, 0x01);
    write_SCCB(0x09, 0x02);
    write_SCCB(0x04, 0x28);
    write_SCCB(0x13, 0xe5);
    write_SCCB(0x14, 0x48);
    write_SCCB(0x2c, 0x0c);
    write_SCCB(0x33, 0x78);
    write_SCCB(0x3a, 0x33);
    write_SCCB(0x3b, 0xfB);
    write_SCCB(0x3e, 0x00);
    write_SCCB(0x43, 0x11);
    write_SCCB(0x16, 0x10);
    //
    write_SCCB(0x39, 0x82);
    //
    write_SCCB(0x35, 0x88);
    write_SCCB(0x22, 0x0a);
    write_SCCB(0x37, 0x40);
    write_SCCB(0x23, 0x00);
    write_SCCB(0x34, 0xa0);
    write_SCCB(0x36, 0x1a);
    write_SCCB(0x06, 0x02);
    write_SCCB(0x07, 0xc0);
    write_SCCB(0x0d, 0xb7);
    write_SCCB(0x0e, 0x01);
    write_SCCB(0x4c, 0x00);
    write_SCCB(0x48, 0x00);
    write_SCCB(0x5B, 0x00);
    write_SCCB(0x42, 0x83);
    //
    write_SCCB(0x4a, 0x81);
    write_SCCB(0x21, 0x99);
    //
    write_SCCB(0x24, 0x40);
    write_SCCB(0x25, 0x38);
    write_SCCB(0x26, 0x82);
    write_SCCB(0x5c, 0x00);
    write_SCCB(0x63, 0x00);
    write_SCCB(0x46, 0x00);
    write_SCCB(0x0c, 0x38);
    //
    write_SCCB(0x61, 0x70);
    write_SCCB(0x62, 0x80);
    write_SCCB(0x7c, 0x05);
    //
    write_SCCB(0x20, 0x80);
    write_SCCB(0x28, 0x30);
    write_SCCB(0x6c, 0x00);
    write_SCCB(0x6d, 0x80);
    write_SCCB(0x6e, 0x00);
    write_SCCB(0x70, 0x02);
    write_SCCB(0x71, 0x94);
    write_SCCB(0x73, 0xc1);
    //
    write_SCCB(0x3d, 0x34);
    write_SCCB(0x5a, 0x57);
    write_SCCB(0x4f, 0xbb);
    write_SCCB(0x50, 0x9c);
    //
    //
    write_SCCB(0xff, 0x00);
    write_SCCB(0xe5, 0x7f);
    write_SCCB(0xf9, 0xc0);
    write_SCCB(0x41, 0x24);
    write_SCCB(0xe0, 0x14);
    write_SCCB(0x76, 0xff);
    write_SCCB(0x33, 0xa0);
    write_SCCB(0x42, 0x20);
    write_SCCB(0x43, 0x18);
    write_SCCB(0x4c, 0x00);
    write_SCCB(0x87, 0xd0);
    write_SCCB(0x88, 0x3f);
    write_SCCB(0xd7, 0x03);
    write_SCCB(0xd9, 0x10);
    write_SCCB(0xd3, 0x82);
    //
    write_SCCB(0xc8, 0x08);
    write_SCCB(0xc9, 0x80);
    //
    write_SCCB(0x7c, 0x00);
    write_SCCB(0x7d, 0x00);
    write_SCCB(0x7c, 0x03);
    write_SCCB(0x7d, 0x48);
    write_SCCB(0x7d, 0x48);
    write_SCCB(0x7c, 0x08);
    write_SCCB(0x7d, 0x20);
    write_SCCB(0x7d, 0x10);
    write_SCCB(0x7d, 0x0e);
    //
    write_SCCB(0x90, 0x00);
    write_SCCB(0x91, 0x0e);
    write_SCCB(0x91, 0x1a);
    write_SCCB(0x91, 0x31);
    write_SCCB(0x91, 0x5a);
    write_SCCB(0x91, 0x69);
    write_SCCB(0x91, 0x75);
    write_SCCB(0x91, 0x7e);
    write_SCCB(0x91, 0x88);
    write_SCCB(0x91, 0x8f);
    write_SCCB(0x91, 0x96);
    write_SCCB(0x91, 0xa3);
    write_SCCB(0x91, 0xaf);
    write_SCCB(0x91, 0xc4);
    write_SCCB(0x91, 0xd7);
    write_SCCB(0x91, 0xe8);
    write_SCCB(0x91, 0x20);
    //
    write_SCCB(0x92, 0x00);
    write_SCCB(0x93, 0x06);
    write_SCCB(0x93, 0xe3);
    write_SCCB(0x93, 0x05);
    write_SCCB(0x93, 0x05);
    write_SCCB(0x93, 0x00);
    write_SCCB(0x93, 0x04);
    write_SCCB(0x93, 0x00);
    write_SCCB(0x93, 0x00);
    write_SCCB(0x93, 0x00);
    write_SCCB(0x93, 0x00);
    write_SCCB(0x93, 0x00);
    write_SCCB(0x93, 0x00);
    write_SCCB(0x93, 0x00);
    //
    write_SCCB(0x96, 0x00);
    write_SCCB(0x97, 0x08);
    write_SCCB(0x97, 0x19);
    write_SCCB(0x97, 0x02);
    write_SCCB(0x97, 0x0c);
    write_SCCB(0x97, 0x24);
    write_SCCB(0x97, 0x30);
    write_SCCB(0x97, 0x28);
    write_SCCB(0x97, 0x26);
    write_SCCB(0x97, 0x02);
    write_SCCB(0x97, 0x98);
    write_SCCB(0x97, 0x80);
    write_SCCB(0x97, 0x00);
    write_SCCB(0x97, 0x00);
    //
    write_SCCB(0xc3, 0xed);
    write_SCCB(0xc4, 0x9a);
    write_SCCB(0xa4, 0x00);
    write_SCCB(0xa8, 0x00);
    write_SCCB(0xc5, 0x11);
    write_SCCB(0xc6, 0x51);
    write_SCCB(0xbf, 0x80);
    write_SCCB(0xc7, 0x10);
    write_SCCB(0xb6, 0x66);
    write_SCCB(0xb8, 0xA5);
    write_SCCB(0xb7, 0x64);
    write_SCCB(0xb9, 0x7C);
    write_SCCB(0xb3, 0xaf);
    write_SCCB(0xb4, 0x97);
    write_SCCB(0xb5, 0xFF);
    write_SCCB(0xb0, 0xC5);
    write_SCCB(0xb1, 0x94);
    write_SCCB(0xb2, 0x0f);
    write_SCCB(0xc4, 0x5c);
    //
    write_SCCB(0xc0, 0xc8);
    write_SCCB(0xc1, 0x96);
    write_SCCB(0x86, 0x1d);
    write_SCCB(0x50, 0x00);
    write_SCCB(0x51, 0x90);
    write_SCCB(0x52, 0x2c);
    write_SCCB(0x53, 0x00);
    write_SCCB(0x54, 0x00);
    write_SCCB(0x55, 0x88);
    write_SCCB(0x57, 0x00);
    write_SCCB(0x5a, 0x90);
    write_SCCB(0x5b, 0x2c);
    write_SCCB(0x5c, 0x05);
    //
    write_SCCB(0xc3, 0xed);
    write_SCCB(0x7f, 0x00);
    //
    write_SCCB(0xda, 0x00);
    //
    write_SCCB(0xe5, 0x1f);
    write_SCCB(0xe1, 0x67);
    write_SCCB(0xe0, 0x00);
    write_SCCB(0xdd, 0x7f);
    write_SCCB(0x05, 0x00);
}
void ov2640_Dothin(void)
{
    write_SCCB(0xFF, 0x01);
    write_SCCB(0x12, 0x80);
    DJY_EventDelay(1000);
    write_SCCB(0xFF, 0x00);
    write_SCCB(0xFF, 0x00);
    write_SCCB(0x2C, 0xFF);
    write_SCCB(0x2E, 0xDF);
    write_SCCB(0xFF, 0x01);
    write_SCCB(0x3C, 0x32);
    write_SCCB(0x11, 0x00);
    write_SCCB(0x09, 0x02);
    write_SCCB(0x03, 0xCF);
    write_SCCB(0x04, 0x08);
    write_SCCB(0x13, 0xE5);
    write_SCCB(0x14, 0x48);
    write_SCCB(0x2C, 0x0C);
    write_SCCB(0x33, 0x78);
    write_SCCB(0x3A, 0x33);
    write_SCCB(0x3B, 0xFB);
    write_SCCB(0x3E, 0x00);
    write_SCCB(0x43, 0x11);
    write_SCCB(0x16, 0x10);
    write_SCCB(0x39, 0x02);
    write_SCCB(0x35, 0x88);
    write_SCCB(0x22, 0x0A);
    write_SCCB(0x37, 0x40);
    write_SCCB(0x23, 0x00);
    write_SCCB(0x34, 0xA0);
    write_SCCB(0x36, 0x1A);
    write_SCCB(0x06, 0x02);
    write_SCCB(0x07, 0xC0);
    write_SCCB(0x0D, 0xB7);
    write_SCCB(0x0E, 0x01);
    write_SCCB(0x4C, 0x00);
    write_SCCB(0x4A, 0x81);
    write_SCCB(0x21, 0x99);
    write_SCCB(0x24, 0x3A);
    write_SCCB(0x25, 0x32);
    write_SCCB(0x26, 0x82);
    write_SCCB(0x5C, 0x00);
    write_SCCB(0x63, 0x00);
    write_SCCB(0x5D, 0x55);
    write_SCCB(0x5E, 0x7D);
    write_SCCB(0x5F, 0x7D);
    write_SCCB(0x60, 0x55);
    write_SCCB(0x61, 0x70);
    write_SCCB(0x62, 0x80);
    write_SCCB(0x7C, 0x05);
    write_SCCB(0x20, 0x80);
    write_SCCB(0x28, 0x30);
    write_SCCB(0x6C, 0x00);
    write_SCCB(0x6D, 0x80);
    write_SCCB(0x6E, 0x00);
    write_SCCB(0x70, 0x02);
    write_SCCB(0x71, 0x96);
    write_SCCB(0x73, 0xE1);
    write_SCCB(0x3D, 0x34);
    write_SCCB(0x5A, 0x57);
    write_SCCB(0x4F, 0xBB);
    write_SCCB(0x50, 0x9C);
    write_SCCB(0x0F, 0x43);
    write_SCCB(0xFF, 0x00);
    write_SCCB(0xE5, 0x7F);
    write_SCCB(0xF9, 0xC0);
    write_SCCB(0x41, 0x24);
    write_SCCB(0xE0, 0x14);
    write_SCCB(0x76, 0xFF);
    write_SCCB(0x33, 0xA0);
    write_SCCB(0x42, 0x20);
    write_SCCB(0x43, 0x18);
    write_SCCB(0x4C, 0x00);
    write_SCCB(0x87, 0xD0);
    write_SCCB(0x88, 0x3F);
    write_SCCB(0xD7, 0x03);
    write_SCCB(0xD9, 0x10);
    write_SCCB(0xD3, 0x82);
    write_SCCB(0xC8, 0x08);
    write_SCCB(0xC9, 0x80);
    write_SCCB(0x7C, 0x00);
    write_SCCB(0x7D, 0x02);
    write_SCCB(0x7C, 0x03);
    write_SCCB(0x7D, 0x48);
    write_SCCB(0x7D, 0x48);
    write_SCCB(0x7C, 0x08);
    write_SCCB(0x7D, 0x20);
    write_SCCB(0x7D, 0x10);
    write_SCCB(0x7D, 0x0E);
    write_SCCB(0x90, 0x00);
    write_SCCB(0x91, 0x0E);
    write_SCCB(0x91, 0x1A);
    write_SCCB(0x91, 0x31);
    write_SCCB(0x91, 0x5A);
    write_SCCB(0x91, 0x69);
    write_SCCB(0x91, 0x75);
    write_SCCB(0x91, 0x7E);
    write_SCCB(0x91, 0x88);
    write_SCCB(0x91, 0x8F);
    write_SCCB(0x91, 0x96);
    write_SCCB(0x91, 0xA3);
    write_SCCB(0x91, 0xAF);
    write_SCCB(0x91, 0xC4);
    write_SCCB(0x91, 0xD7);
    write_SCCB(0x91, 0xE8);
    write_SCCB(0x91, 0x20);
    write_SCCB(0x92, 0x00);
    write_SCCB(0x93, 0x06);
    write_SCCB(0x93, 0xE3);
    write_SCCB(0x93, 0x05);
    write_SCCB(0x93, 0x05);
    write_SCCB(0x93, 0x00);
    write_SCCB(0x93, 0x00);
    write_SCCB(0x93, 0x00);
    write_SCCB(0x93, 0x00);
    write_SCCB(0x93, 0x00);
    write_SCCB(0x93, 0x00);
    write_SCCB(0x93, 0x00);
    write_SCCB(0x93, 0x00);
    write_SCCB(0x93, 0x00);
    write_SCCB(0x96, 0x00);
    write_SCCB(0x97, 0x08);
    write_SCCB(0x97, 0x19);
    write_SCCB(0x97, 0x02);
    write_SCCB(0x97, 0x0C);
    write_SCCB(0x97, 0x24);
    write_SCCB(0x97, 0x30);
    write_SCCB(0x97, 0x28);
    write_SCCB(0x97, 0x26);
    write_SCCB(0x97, 0x02);
    write_SCCB(0x97, 0x98);
    write_SCCB(0x97, 0x80);
    write_SCCB(0x97, 0x00);
    write_SCCB(0x97, 0x00);
    write_SCCB(0xC3, 0xED);
    write_SCCB(0xA4, 0x00);
    write_SCCB(0xA8, 0x00);
    write_SCCB(0xBF, 0x00);
    write_SCCB(0xBA, 0xF0);
    write_SCCB(0xBC, 0x64);
    write_SCCB(0xBB, 0x02);
    write_SCCB(0xB6, 0x3D);
    write_SCCB(0xB8, 0x57);
    write_SCCB(0xB7, 0x38);
    write_SCCB(0xB9, 0x4E);
    write_SCCB(0xB3, 0xE8);
    write_SCCB(0xB4, 0xE1);
    write_SCCB(0xB5, 0x66);
    write_SCCB(0xB0, 0x67);
    write_SCCB(0xB1, 0x5E);
    write_SCCB(0xB2, 0x04);
    write_SCCB(0xC7, 0x00);
    write_SCCB(0xC6, 0x51);
    write_SCCB(0xC5, 0x11);
    write_SCCB(0xC4, 0x9C);
    write_SCCB(0xCF, 0x02);
    write_SCCB(0xA6, 0x00);
    write_SCCB(0xA7, 0xE0);
    write_SCCB(0xA7, 0x10);
    write_SCCB(0xA7, 0x1E);
    write_SCCB(0xA7, 0x21);
    write_SCCB(0xA7, 0x00);
    write_SCCB(0xA7, 0x28);
    write_SCCB(0xA7, 0xD0);
    write_SCCB(0xA7, 0x10);
    write_SCCB(0xA7, 0x16);
    write_SCCB(0xA7, 0x21);
    write_SCCB(0xA7, 0x00);
    write_SCCB(0xA7, 0x28);
    write_SCCB(0xA7, 0xD0);
    write_SCCB(0xA7, 0x10);
    write_SCCB(0xA7, 0x17);
    write_SCCB(0xA7, 0x21);
    write_SCCB(0xA7, 0x00);
    write_SCCB(0xA7, 0x28);
    write_SCCB(0xC0, 0xC8);
    write_SCCB(0xC1, 0x96);
    write_SCCB(0x86, 0x1D);
    write_SCCB(0x50, 0x00);
    write_SCCB(0x51, 0x90);
    write_SCCB(0x52, 0x18);
    write_SCCB(0x53, 0x00);
    write_SCCB(0x54, 0x00);
    write_SCCB(0x55, 0x88);
    write_SCCB(0x57, 0x00);
    write_SCCB(0x5A, 0x90);
    write_SCCB(0x5B, 0x18);
    write_SCCB(0x5C, 0x05);
    write_SCCB(0xC3, 0xEF);
    write_SCCB(0x7F, 0x00);
    write_SCCB(0xDA, 0x00);
    write_SCCB(0xE5, 0x1F);
    write_SCCB(0xE1, 0x67);
    write_SCCB(0xE0, 0x00);
    write_SCCB(0xDD, 0xFF);
    write_SCCB(0x05, 0x00);
    write_SCCB(0xFF, 0x01);
    write_SCCB(0xFF, 0x01);
    write_SCCB(0x12, 0x00);
    write_SCCB(0x17, 0x11);
    write_SCCB(0x18, 0x75);
    write_SCCB(0x19, 0x01);
    write_SCCB(0x1A, 0x97);
    write_SCCB(0x32, 0x36);
    write_SCCB(0x4F, 0xBB);
    write_SCCB(0x50, 0x9C);
    write_SCCB(0x5A, 0x57);
    write_SCCB(0x6D, 0x80);
    write_SCCB(0x39, 0x02);
    write_SCCB(0x35, 0x88);
    write_SCCB(0x22, 0x0A);
    write_SCCB(0x37, 0x40);
    write_SCCB(0x23, 0x00);
    write_SCCB(0x34, 0xA0);
    write_SCCB(0x36, 0x1A);
    write_SCCB(0x06, 0x02);
    write_SCCB(0x07, 0xC0);
    write_SCCB(0x0D, 0xB7);
    write_SCCB(0x0E, 0x01);
    write_SCCB(0x4C, 0x00);
    write_SCCB(0xFF, 0x00);
    write_SCCB(0xE0, 0x04);
    write_SCCB(0xC0, 0xC8);
    write_SCCB(0xC1, 0x96);
    write_SCCB(0x86, 0x1D);
    write_SCCB(0x50, 0x00);
    write_SCCB(0x51, 0x90);
    write_SCCB(0x52, 0x2C);
    write_SCCB(0x53, 0x00);
    write_SCCB(0x54, 0x00);
    write_SCCB(0x55, 0x88);
    write_SCCB(0x57, 0x00);
    write_SCCB(0x5A, 0x90);
    write_SCCB(0x5B, 0x2C);
    write_SCCB(0x5C, 0x05);
    write_SCCB(0xE0, 0x00);
    write_SCCB(0xFF, 0x01);
    write_SCCB(0x11, 0x01);
    write_SCCB(0x3D, 0x34);
    write_SCCB(0x50, 0x80);
    write_SCCB(0xFF, 0x00);
    write_SCCB(0xD3, 0x82);
    write_SCCB(0xFF, 0x01);
}

const uint8_t ov2640_yuv422_reg_tbl[][2]=
{
    0xFF, 0x00,
    0xDA, 0x00,
    0xE5, 0x1F,
    0xE1, 0x67,
    0xE0, 0x00,
    0xDD, 0xFF,
    0x05, 0x00,
};
const uint8_t ov2640_jpeg_reg_tbl[][2]=
{
    0xff, 0x00,
    0xe0, 0x14,
    0xe1, 0x77,
    0xe5, 0x1f,
    0xd7, 0x03,
    0xda, 0x10,
    0xe0, 0x00,
};
/**
 * @brief       OV2640 切换为JPEG模式
 * @param       无
 * @retval      无
 */
void ov2640_yuv422_mode(void)
{
    uint16_t i = 0;

    /* 设置:YUV422格式 */
    for (i = 0; i < (sizeof(ov2640_yuv422_reg_tbl) / 2); i++)
    {
        write_SCCB(ov2640_yuv422_reg_tbl[i][0], ov2640_yuv422_reg_tbl[i][1]); /* 发送配置数组 */
    }
}

/**
 * @brief       OV2640 切换为JPEG模式
 * @param       无
 * @retval      无
 */
void ov2640_jpeg_mode(void)
{
    uint16_t i = 0;

    /* 设置:YUV422格式 */
//  for (i = 0; i < (sizeof(ov2640_yuv422_reg_tbl) / 2); i++)
//  {
//      ov2640_write_reg(ov2640_yuv422_reg_tbl[i][0], ov2640_yuv422_reg_tbl[i][1]); /* 发送配置数组 */
//  }

    /* 设置:输出JPEG数据 */
    for (i = 0; i < (sizeof(ov2640_jpeg_reg_tbl) / 2); i++)
    {
        write_SCCB(ov2640_jpeg_reg_tbl[i][0], ov2640_jpeg_reg_tbl[i][1]);     /* 发送配置数组 */
    }
}

void xtq_config(void)
{
    int TableSize=_REG_TABLE_SIZE(g_sOV2640_RegValue);
    int i;
    for(i=0;i<TableSize;i++)
    {
        OV2640_WriteReg((g_sOV2640_RegValue[i].u8RegAddr), (g_sOV2640_RegValue[i].u8Value));
        if ((g_sOV2640_RegValue[i].u8RegAddr)==0x12 && (g_sOV2640_RegValue[i].u8Value)==0x80)
        {
            delay_ms(1);
            sysprintf("Delay A loop \r\n");
        }
    }
}

/*寄存器地址*/
#define OV2640_DSP_RA_DLMT 0xFF
#define OV2640_SENSOR_MIDH 0x1C
#define OV2640_SENSOR_MIDL 0x1D
#define OV2640_SENSOR_PIDH 0x0A
#define OV2640_SENSOR_PIDL 0x0B
/*
ov2640 读ID
*/
void OV2640_ReadID(OV2640_IDTypeDef *OV2640ID)
{
    /*OV2640有两组寄存器，设置0xFF寄存器的值为0或为1时可选择使用不同组的寄存器*/
    OV2640_WriteReg(OV2640_DSP_RA_DLMT, 0x01);
    /*读取寄存芯片ID*/
    OV2640ID->Manufacturer_ID1 = OV2640_ReadReg(OV2640_SENSOR_MIDH);
    OV2640ID->Manufacturer_ID2 = OV2640_ReadReg(OV2640_SENSOR_MIDL);
    OV2640ID->PIDH             = OV2640_ReadReg(OV2640_SENSOR_PIDH);
    OV2640ID->PIDL             = OV2640_ReadReg(OV2640_SENSOR_PIDL);
}
/*
ov2640 配置
*/
int OV2640_Config(void)
{
    int i=0;
//  int TableSize=_REG_TABLE_SIZE(g_sOV2640_RegValue);
//    struct OV_RegValue *psRegValue=g_sOV2640_RegValue;
    OV2640_IDTypeDef OV2640_Camera_ID;

    OV2640_ReadID(&OV2640_Camera_ID);
    if (OV2640_Camera_ID.PIDH == 0x26)
    {
        sysprintf("检测到OV2640摄像头 \r\n");
        sysprintf("OV2640 : %x %x \r\n",OV2640_Camera_ID.Manufacturer_ID1 ,OV2640_Camera_ID.Manufacturer_ID2);
    }
    else
    {
        sysprintf("没有检测到OV2640摄像头，请重新检查连接 \r\n");
        return -1;
    }
  //配置初始化
//    sysprintf("write config...\r\n");
//    sysprintf("config size:%d\r\n",TableSize);
//    sysprintf("config value addr:%x\r\n",psRegValue);
//    ov2640_SvgaPreview();
//ov2640_UxgaCapture();
    ov2640_Dothin();
//  xtq_config();

    //  OV2640_WriteReg(TWI,OV2640_DSP_RA_DLMT, 0x01);
//  sysprintf("D %x \r\n",OV2640_ReadReg(TWI,0x11));
    return 0;
}

// =============================================================================
// 功能：OV2640 模块初始化，
// 参数：无
// 返回：true,成功;false,失败
// =============================================================================
bool_t OV2640_Init(void)
{
    bool_t result = false;
    static struct IIC_Device* s_OV2640_Dev;

    PWM_Init(0,24000000,50,1);//输出24MHZ时钟

    //添加ov2640-sccb到IIC总线
    ps_OV2640_Dev = IIC_DevAdd(CFG_OV2640_BUS_NAME,"IIC_ov2640_sccb", SCCB_ADDR >> 1,
                            0, OV2640_ADDR_BITS);
    if(NULL != ps_OV2640_Dev)
    {
        OV2640_Config();    //发送配置参数
        result = true;
    }

    return result;
}




