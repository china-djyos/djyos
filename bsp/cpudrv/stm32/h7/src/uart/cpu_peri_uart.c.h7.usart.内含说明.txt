//----------------------------------------------------
// Copyright (c) 2018, Djyos Open source Development team. All rights reserved.

// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:

// 1. Redistributions of source code must retain the above copyright notice,
//    this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright notice,
//    this list of conditions and the following disclaimer in the documentation
//    and/or other materials provided with the distribution.

// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
//-----------------------------------------------------------------------------
// Copyright (c) 2018，著作权由都江堰操作系统开源开发团队所有。著作权人保留一切权利。
//
// 这份授权条款，在使用者符合下列条件的情形下，授予使用者使用及再散播本
// 软件包装原始码及二进位可执行形式的权利，无论此包装是否经改作皆然：
//
// 1. 对于本软件源代码的再散播，必须保留上述的版权宣告、本条件列表，以
//    及下述的免责声明。
// 2. 对于本套件二进位可执行形式的再散播，必须连带以文件以及／或者其他附
//    于散播包装中的媒介方式，重制上述之版权宣告、本条件列表，以及下述
//    的免责声明。

// 免责声明：本软件是本软件版权持有人以及贡献者以现状（"as is"）提供，
// 本软件包装不负任何明示或默示之担保责任，包括但不限于就适售性以及特定目
// 的的适用性为默示性担保。版权持有人及本软件之贡献者，无论任何条件、
// 无论成因或任何责任主体、无论此责任为因合约关系、无过失责任主体或因非违
// 约之侵权（包括过失或其他原因等）而起，对于任何因使用本软件包装所产生的
// 任何直接性、间接性、偶发性、特殊性、惩罚性或任何结果的损害（包括但不限
// 于替代商品或劳务之购用、使用损失、资料损失、利益损失、业务中断等等），
// 不负任何责任，即在该种使用已获事前告知可能会造成此类损害的情形下亦然。
//-----------------------------------------------------------------------------
// =============================================================================

// 文件名     ：cpu_peri_uart.c
// 模块描述: DJYOS串口模块的底层驱动部分，主要实现寄存器级别的操作，如中断等
// 模块版本: V1.10
// 创建人员:
// 创建时间:
// =============================================================================
#include "stdint.h"
#include "stdio.h"
#include <stdlib.h>
#include "string.h"
#include "errno.h"
#include "systime.h"
#include "cpu_peri.h"
#include <device/djy_uart.h>
#include "int.h"
#include "djyos.h"
#include "cpu_peri_uart.h"
#include "cpu_peri_int_line.h"
#include "project_config.h"     //本文件由IDE中配置界面生成，存放在APP的工程目录中。
                                //允许是个空文件，所有配置将按默认值配置。

//@#$%component configure   ****组件配置开始，用于 DIDE 中图形化配置界面
//****配置块的语法和使用方法，参见源码根目录下的文件：component_config_readme.txt****
//%$#@initcode      ****初始化代码开始，由 DIDE 删除“//”后copy到初始化文件中
//    extern ptu32_t ModuleInstall_UART(ptu32_t SerialNo);
//
//    #if CFG_USART1_ENABLE ==1
//    ModuleInstall_UART(CN_USART1);
//    #endif
//
//    #if CFG_USART2_ENABLE ==1
//    ModuleInstall_UART(CN_USART2);
//    #endif
//
//    #if CFG_USART3_ENABLE ==1
//    ModuleInstall_UART(CN_USART3);
//    #endif
//
//    #if CFG_UART4_ENABLE ==1
//    ModuleInstall_UART(CN_UART4);
//    #endif
//
//    #if CFG_UART5_ENABLE ==1
//    ModuleInstall_UART(CN_UART5);
//    #endif
//
//    #if CFG_USART6_ENABLE ==1
//    ModuleInstall_UART(CN_USART6);
//    #endif
//
//    #if CFG_UART7_ENABLE ==1
//    ModuleInstall_UART(CN_UART7);
//    #endif
//
//    #if CFG_UART8_ENABLE ==1
//    ModuleInstall_UART(CN_UART8);
//    #endif

//    #if CFG_UART9_ENABLE ==1
//    ModuleInstall_UART(CN_UART9);
//    #endif

//    #if CFG_USART10_ENABLE ==1
//    ModuleInstall_UART(CN_USART10);
//    #endif
//%$#@end initcode  ****初始化代码结束

//%$#@describe      ****组件描述开始
//component name:"cpu onchip uart"//CPU的uart外设驱动
//parent:"uart device file"      //填写该组件的父组件名字，none表示没有父组件
//attribute:bsp                 //选填“third、system、bsp、user”，本属性用于在IDE中分组
//select:choosable              //选填“required、choosable、none”，若填必选且需要配置参数，则IDE裁剪界面中默认勾取，
                                //不可取消，必选且不需要配置参数的，或是不可选的，IDE裁剪界面中不显示，
//init time:early               //初始化时机，可选值：early，medium，later, pre-main。
                                //表示初始化时间，分别是早期、中期、后期
//dependence:"device file system","lock","uart device file","heap"//该组件的依赖组件名（可以是none，表示无依赖组件），
                                //选中该组件时，被依赖组件将强制选中，
                                //如果依赖多个组件，则依次列出，用“,”分隔
//weakdependence:"none"         //该组件的弱依赖组件名（可以是none，表示无依赖组件），
                                //选中该组件时，被依赖组件不会被强制选中，
                                //如果依赖多个组件，则依次列出，用“,”分隔
//mutex:"none"                  //该组件的互斥组件名（可以是none，表示无互斥组件），
                                //如果与多个组件互斥，则依次列出，用“,”分隔
//%$#@end describe  ****组件描述结束

//%$#@configue      ****参数配置开始
#if ( CFG_MODULE_ENABLE_CPU_ONCHIP_UART == false )
//#warning  " cpu_onchip_uart  组件参数未配置，使用默认配置"
//%$#@target = header           //header = 生成头文件,cmdline = 命令行变量，DJYOS自有模块禁用
#define CFG_MODULE_ENABLE_CPU_ONCHIP_UART    false //如果勾选了本组件，将由DIDE在project_config.h或命令行中定义为true
//%$#@num,32,512,
#define CFG_UART_SENDBUF_LEN            32                  //"串口发送环形缓冲区大小",
#define CFG_UART_RECVBUF_LEN            32                  //"串口接收环形缓冲区大小",

//%$#@enum,false,true
#define CFG_USART1_ENABLE               true                //"配置是否使用USART1",
#define CFG_USART2_ENABLE               false               //"配置是否使用USART2",
#define CFG_USART3_ENABLE               false               //"配置是否使用USART3",
#define CFG_UART4_ENABLE                false               //"配置是否使用UART4",
#define CFG_UART5_ENABLE                false               //"配置是否使用UART5",
#define CFG_USART6_ENABLE               false               //"配置是否使用USART6",
#define CFG_UART7_ENABLE                false               //"配置是否使用UART7",
#define CFG_UART8_ENABLE                false               //"配置是否使用UART8",
#define CFG_UART9_ENABLE                false               //"配置是否使用UART9",
#define CFG_USART10_ENABLE              false               //"配置是否使用USART10",
//%$#@string,1,10,
//%$#select,        ***从列出的选项中选择若干个定义成宏
//%$#@free,
#endif
//%$#@end configue  ****参数配置结束
//@#$%component end configure
// =============================================================================

#define tagUartReg USART_TypeDef        //uart和usart寄存器相同

// =============================================================================
#define IAM_UART  1
#define IAM_USART 0
typedef struct
{
    char* Name;
    tagUartReg volatile *Reg;
    u8 TxRxIntLine;
    u8 DmaRxIntLine;
    u8 DmaTxIntLine;
    u8 isUart;      //1 = uart,0 = usart
    uint32_t DmaRxReq;
    uint32_t DmaTxReq;
    DMA_Stream_TypeDef * DmaRxCh;
    DMA_Stream_TypeDef * DmaTxCh;
}tagUartCfg;

static const tagUartCfg sUartCfg[CN_UART_NUM] = {
    {   .Name         =  "UART1",
        .Reg          =  (tagUartReg volatile *)USART1_BASE,
        .TxRxIntLine  =  CN_INT_LINE_USART1,
        .DmaRxIntLine =  CN_INT_LINE_DMA1_Stream5,
        .DmaTxIntLine =  CN_INT_LINE_DMA1_Stream7,
        .isUart       =  IAM_USART,
        .DmaRxReq     =  DMA_REQUEST_USART1_RX,
        .DmaTxReq     =  DMA_REQUEST_USART1_TX,
        .DmaRxCh      =  DMA1_Stream5,
        .DmaTxCh      =  DMA1_Stream7
    },
    {   .Name         =  "UART2",
        .Reg          =  (tagUartReg volatile *)USART2_BASE,
        .TxRxIntLine  =  CN_INT_LINE_USART2,
        .DmaRxIntLine =  CN_INT_LINE_DMA1_Stream5,
        .DmaTxIntLine =  CN_INT_LINE_DMA1_Stream7,
        .isUart       =  IAM_USART,
        .DmaRxReq     =  DMA_REQUEST_USART2_RX,
        .DmaTxReq     =  DMA_REQUEST_USART2_TX,
        .DmaRxCh      =  DMA1_Stream5,
        .DmaTxCh      =  DMA1_Stream7
    },
    {   .Name         =  "UART3",
        .Reg          =  (tagUartReg volatile *)USART3_BASE,
        .TxRxIntLine  =  CN_INT_LINE_USART3,
        .DmaRxIntLine =  CN_INT_LINE_DMA1_Stream5,
        .DmaTxIntLine =  CN_INT_LINE_DMA1_Stream7,
        .isUart       =  IAM_UART,
        .DmaRxReq     =  DMA_REQUEST_USART3_RX,
        .DmaTxReq     =  DMA_REQUEST_USART3_TX,
        .DmaRxCh      =  DMA1_Stream5,
        .DmaTxCh      =  DMA1_Stream7
    },
    {   .Name         =  "UART4",
        .Reg          =  (tagUartReg volatile *)UART4_BASE,
        .TxRxIntLine  =  CN_INT_LINE_UART4,
        .DmaRxIntLine =  CN_INT_LINE_DMA1_Stream5,
        .DmaTxIntLine =  CN_INT_LINE_DMA1_Stream7,
        .isUart       =  IAM_UART,
        .DmaRxReq     =  DMA_REQUEST_UART4_RX,
        .DmaTxReq     =  DMA_REQUEST_UART4_TX,
        .DmaRxCh      =  DMA1_Stream5,
        .DmaTxCh      =  DMA1_Stream7
    },
    {   .Name         =  "UART5",
        .Reg          =  (tagUartReg volatile *)UART5_BASE,
        .TxRxIntLine  =  CN_INT_LINE_UART5,
        .DmaRxIntLine =  CN_INT_LINE_DMA1_Stream5,
        .DmaTxIntLine =  CN_INT_LINE_DMA1_Stream7,
        .isUart       =  IAM_UART,
        .DmaRxReq     =  DMA_REQUEST_UART5_RX,
        .DmaTxReq     =  DMA_REQUEST_UART5_TX,
        .DmaRxCh      =  DMA1_Stream5,
        .DmaTxCh      =  DMA1_Stream7
    },
    {   .Name         =  "UART6",
        .Reg          =  (tagUartReg volatile *)USART6_BASE,
        .TxRxIntLine  =  CN_INT_LINE_USART6,
        .DmaRxIntLine =  CN_INT_LINE_DMA1_Stream5,
        .DmaTxIntLine =  CN_INT_LINE_DMA1_Stream7,
        .isUart       =  IAM_USART,
        .DmaRxReq     =  DMA_REQUEST_USART6_RX,
        .DmaTxReq     =  DMA_REQUEST_USART6_TX,
        .DmaRxCh      =  DMA1_Stream5,
        .DmaTxCh      =  DMA1_Stream7
    },
    {   .Name         =  "UART7",
        .Reg          =  (tagUartReg volatile *)UART7_BASE,
        .TxRxIntLine  =  CN_INT_LINE_UART7,
        .DmaRxIntLine =  CN_INT_LINE_DMA1_Stream5,
        .DmaTxIntLine =  CN_INT_LINE_DMA1_Stream7,
        .isUart       =  IAM_UART,
        .DmaRxReq     =  DMA_REQUEST_UART7_RX,
        .DmaTxReq     =  DMA_REQUEST_UART7_TX,
        .DmaRxCh      =  DMA1_Stream5,
        .DmaTxCh      =  DMA1_Stream7
    },
    {   .Name         =  "UART8",
        .Reg          =  (tagUartReg volatile *)UART8_BASE,
        .TxRxIntLine  =  CN_INT_LINE_UART8,
        .DmaRxIntLine =  CN_INT_LINE_DMA1_Stream5,
        .DmaTxIntLine =  CN_INT_LINE_DMA1_Stream7,
        .isUart       =  IAM_UART,
        .DmaRxReq     =  DMA_REQUEST_UART8_RX,
        .DmaTxReq     =  DMA_REQUEST_UART8_TX,
        .DmaRxCh      =  DMA1_Stream5,
        .DmaTxCh      =  DMA1_Stream7
    },
    {   .Name         =  "UART9",
        .Reg          =  (tagUartReg volatile *)UART9_BASE,
        .TxRxIntLine  =  CN_INT_LINE_UART9,
        .DmaRxIntLine =  CN_INT_LINE_DMA1_Stream5,
        .DmaTxIntLine =  CN_INT_LINE_DMA1_Stream7,
        .isUart       =  IAM_UART,
        .DmaRxReq     =  DMA_REQUEST_UART9_RX,
        .DmaTxReq     =  DMA_REQUEST_UART9_TX,
        .DmaRxCh      =  DMA1_Stream5,
        .DmaTxCh      =  DMA1_Stream7
    },
    {   .Name         =  "UART10",
        .Reg          =  (tagUartReg volatile *)USART10_BASE,
        .TxRxIntLine  =  CN_INT_LINE_USART10,
        .DmaRxIntLine =  CN_INT_LINE_DMA1_Stream5,
        .DmaTxIntLine =  CN_INT_LINE_DMA1_Stream7,
        .isUart       =  IAM_USART,
        .DmaRxReq     =  DMA_REQUEST_USART10_RX,
        .DmaTxReq     =  DMA_REQUEST_USART10_TX,
        .DmaRxCh      =  DMA1_Stream5,
        .DmaTxCh      =  DMA1_Stream7
    },
};
// =============================================================================

//#define CFG_UART_SENDBUF_LEN    32
//#define CFG_UART_RECVBUF_LEN     32

static u32 TxByteTime;                    //正常发送一个字节所需要的时间
static void *PutStrDirectH;               //用于printk发送的串口
static void *GetCharDirectH;      //用于直接接收的串口
static s32 TxDirectPort;                  //用于printk发送的串口号
static s32 RxDirectPort;                  //用于直接接收的串口号
// =============================================================================

static struct UartGeneralCB *pUartCB[CN_UART_NUM];
static u8* pUartSndBuf[CN_UART_NUM] = {NULL};
static u8* pUartRcvBuf[CN_UART_NUM] = {NULL};
static bool_t sUartDmaUsed[] = {false,false,false,false,false,false,false,false};
static bool_t sUartSending[] = {false,false,false,false,false,false,false,false};
static u8 sDmaRcvOff[CN_UART_NUM] = {0};

static void *spHuart[CN_UART_NUM];  //串口4、5、7、8、9为 UART_HandleTypeDef *
                                    //串口1、2、3、6、10为 UART_HandleTypeDef *

// =============================================================================
static ptu32_t UART_ISR(ptu32_t IniLine);
__weak void Board_UartHalfDuplexSend(u8 port)
{
    //user added if need out of the file
}
__weak void Board_UartHalfDuplexRecv(u8 port)
{
    //user added if need out of the file
}

static void __UART_StartRecv(u8 port)
{
    if(sUartCfg[port].isUart == IAM_UART)
    {
        if(sUartDmaUsed[port])
        {
            sDmaRcvOff[port] = 0;
            HAL_UART_Receive_DMA((UART_HandleTypeDef*)spHuart[port],pUartRcvBuf[port],CFG_UART_RECVBUF_LEN);
        }
        else
        {
            HAL_UART_Receive_IT((UART_HandleTypeDef*)spHuart[port],pUartRcvBuf[port],CFG_UART_RECVBUF_LEN);
        }
    }
    else
    {
        if(sUartDmaUsed[port])
        {
            sDmaRcvOff[port] = 0;
            HAL_USART_Receive_DMA((USART_HandleTypeDef*)spHuart[port],pUartRcvBuf[port],CFG_UART_RECVBUF_LEN);
        }
        else
        {
            HAL_USART_Receive_IT((USART_HandleTypeDef*)spHuart[port],pUartRcvBuf[port],CFG_UART_RECVBUF_LEN);
        }
    }

}


static void __UART_RCC_Enable(u8 port,u8 en)
{
    if(en)
    {
        switch(port)
        {//使能串口1时钟
        case CN_USART1:      __HAL_RCC_USART1_CLK_ENABLE();        break; //使能串口1时钟
        case CN_USART2:      __HAL_RCC_USART2_CLK_ENABLE();        break;
        case CN_USART3:      __HAL_RCC_USART3_CLK_ENABLE();        break;
        case CN_UART4:      __HAL_RCC_UART4_CLK_ENABLE();         break;
        case CN_UART5:      __HAL_RCC_UART5_CLK_ENABLE();         break;
        case CN_USART6:      __HAL_RCC_USART6_CLK_ENABLE();        break;
        case CN_UART7:      __HAL_RCC_UART7_CLK_ENABLE();         break;
        case CN_UART8:      __HAL_RCC_UART8_CLK_ENABLE();         break;
        case CN_UART9:      __HAL_RCC_UART9_CLK_ENABLE();         break;
        case CN_USART10:      __HAL_RCC_USART10_CLK_ENABLE();        break;
        default:
            break;
        }
    }
    else
    {
        switch(port)
        {
        case CN_USART1:      __HAL_RCC_USART1_CLK_DISABLE();        break;
        case CN_USART2:      __HAL_RCC_USART2_CLK_DISABLE();        break;
        case CN_USART3:      __HAL_RCC_USART3_CLK_DISABLE();        break;
        case CN_UART4:      __HAL_RCC_UART4_CLK_DISABLE();        break;
        case CN_UART5:      __HAL_RCC_UART5_CLK_DISABLE();        break;
        case CN_USART6:      __HAL_RCC_USART6_CLK_DISABLE();        break;
        case CN_UART7:      __HAL_RCC_UART7_CLK_DISABLE();        break;
        case CN_UART8:      __HAL_RCC_UART8_CLK_DISABLE();        break;
        case CN_UART9:      __HAL_RCC_UART9_CLK_DISABLE();        break;
        case CN_USART10:      __HAL_RCC_USART10_CLK_DISABLE();        break;
            break;
        default:
            break;
        }
    }
}
// =============================================================================
// 功能: 设置串口baud,PCLK为25M，CPU主频为216M计算,该驱动只提供9600、19200、57600、
//       115200四种波特率设置
// 参数: Reg,被操作的寄存器组指针
//       port,串口号
//       baud,波特率
// 返回: 无
// =============================================================================
static void __UART_BaudSet(u32 port,u32 baud)
{
    if(port < CN_UART_NUM)
    {
        if(sUartCfg[port].isUart == IAM_UART)
        {
            ((UART_HandleTypeDef*)spHuart[port])->Init.BaudRate = baud;
            HAL_UART_Abort((UART_HandleTypeDef*)spHuart[port]);
            HAL_UART_Init((UART_HandleTypeDef*)spHuart[port]);
        }
        else
        {
            ((USART_HandleTypeDef*)spHuart[port])->Init.BaudRate = baud;
            HAL_USART_Abort((USART_HandleTypeDef*)spHuart[port]);
            HAL_USART_Init((USART_HandleTypeDef*)spHuart[port]);
        }
        __UART_StartRecv(port);
    }
    if(TxDirectPort == port)
    {
        TxByteTime = 11000000/baud;     //1个字节传输时间，按10bit，+10%计算
    }
}

static void __UART_Start(u8 port)
{
    __UART_RCC_Enable(port,1);
    if(sUartCfg[port].isUart == IAM_UART)
    {
        HAL_UART_Abort((UART_HandleTypeDef*)spHuart[port]);
    }
    else
    {
        HAL_USART_Abort((USART_HandleTypeDef*)spHuart[port]);
    }
    __UART_StartRecv(port);
}
static void __UART_Stop(u8 port)
{
    if(sUartCfg[port].isUart == IAM_UART)
    {
        HAL_UART_Abort((UART_HandleTypeDef*)spHuart[port]);
    }
    else
    {
        HAL_USART_Abort((USART_HandleTypeDef*)spHuart[port]);
    }
    __UART_RCC_Enable(port,0);
}

// =============================================================================
// 功能: 有关串口参数的初始化，波特率，停止位，奇偶校验位
// 参数：port,串口号
//      data，参数
// 返回: 无
// =============================================================================
static void __UART_ComConfig(u32 port, struct COMParam *COM)
{
    UART_InitTypeDef  *Init;
    USART_InitTypeDef  *InitS;
    if(port < CN_UART_NUM)
    {
        if(sUartCfg[port].isUart == IAM_UART)
        {
            Init = &((UART_HandleTypeDef*)spHuart[port])->Init;
            Init->BaudRate = COM->BaudRate;
            switch(COM->DataBits)               // data bits
            {
            case CN_UART_DATABITS_8: Init->WordLength = UART_WORDLENGTH_8B;break;
            case CN_UART_DATABITS_9: Init->WordLength = UART_WORDLENGTH_9B;break;
            default:break;
            }

            switch(COM->Parity)                 // parity
            {
            case CN_UART_PARITY_NONE:Init->Parity = UART_PARITY_NONE;break;
            case CN_UART_PARITY_ODD: Init->Parity = UART_PARITY_ODD;break;
            case CN_UART_PARITY_EVEN:Init->Parity = UART_PARITY_EVEN;break;
            default:break;
            }

            switch(COM->StopBits)               // stop bits
            {
            case CN_UART_STOPBITS_1:  Init->StopBits = UART_STOPBITS_1;break;
            case CN_UART_STOPBITS_1_5:Init->StopBits = UART_STOPBITS_1_5;break;
            case CN_UART_STOPBITS_2:  Init->StopBits = UART_STOPBITS_2;break;
            default:break;
            }
        }
        else
        {
            InitS = &((USART_HandleTypeDef*)spHuart[port])->Init;
            InitS->BaudRate = COM->BaudRate;
            switch(COM->DataBits)               // data bits
            {
            case CN_UART_DATABITS_8: InitS->WordLength = UART_WORDLENGTH_8B;break;
            case CN_UART_DATABITS_9: InitS->WordLength = UART_WORDLENGTH_9B;break;
            default:break;
            }

            switch(COM->Parity)                 // parity
            {
            case CN_UART_PARITY_NONE:InitS->Parity = UART_PARITY_NONE;break;
            case CN_UART_PARITY_ODD: InitS->Parity = UART_PARITY_ODD;break;
            case CN_UART_PARITY_EVEN:InitS->Parity = UART_PARITY_EVEN;break;
            default:break;
            }

            switch(COM->StopBits)               // stop bits
            {
            case CN_UART_STOPBITS_1:  InitS->StopBits = UART_STOPBITS_1;break;
            case CN_UART_STOPBITS_1_5:InitS->StopBits = UART_STOPBITS_1_5;break;
            case CN_UART_STOPBITS_2:  InitS->StopBits = UART_STOPBITS_2;break;
            default:break;
            }
        }
        Init->BaudRate = COM->BaudRate;
        switch(COM->DataBits)               // data bits
        {
        case CN_UART_DATABITS_8: Init->WordLength = UART_WORDLENGTH_8B;break;
        case CN_UART_DATABITS_9: Init->WordLength = UART_WORDLENGTH_9B;break;
        default:break;
        }

        switch(COM->Parity)                 // parity
        {
        case CN_UART_PARITY_NONE:Init->Parity = UART_PARITY_NONE;break;
        case CN_UART_PARITY_ODD: Init->Parity = UART_PARITY_ODD;break;
        case CN_UART_PARITY_EVEN:Init->Parity = UART_PARITY_EVEN;break;
        default:break;
        }

        switch(COM->StopBits)               // stop bits
        {
        case CN_UART_STOPBITS_1:  Init->StopBits = UART_STOPBITS_1;break;
        case CN_UART_STOPBITS_1_5:Init->StopBits = UART_STOPBITS_1_5;break;
        case CN_UART_STOPBITS_2:  Init->StopBits = UART_STOPBITS_2;break;
        default:break;
        }

        if(sUartCfg[port].isUart == IAM_UART)
        {
            HAL_UART_Abort((UART_HandleTypeDef*)spHuart[port]);
            HAL_UART_Init((UART_HandleTypeDef*)spHuart[port]);
        }
        else
        {
            HAL_USART_Abort((USART_HandleTypeDef*)spHuart[port]);
            HAL_USART_Init((USART_HandleTypeDef*)spHuart[port]);
        }
        __UART_StartRecv(port);
    }
}


// =============================================================================
// 功能: 初始化UART对应的中断线，并初始化中断入口函数
// 参数：SerialNo,串口号
// 返回: 无
// =============================================================================
static void __UART_IntInit(u32 port)
{
    u8 IntLine;

    IntLine = sUartCfg[port].TxRxIntLine;
    Int_Register(IntLine);
    Int_SetClearType(IntLine,CN_INT_CLEAR_AUTO);
    Int_IsrConnect(IntLine,UART_ISR);
    Int_SetIsrPara(IntLine,port);
    Int_SettoAsynSignal(IntLine);
    Int_ClearLine(IntLine);
    Int_RestoreAsynLine(IntLine);
}

// HAL needed
void HAL_UART_MspInit(UART_HandleTypeDef *huart)
{
    u8 port;
    for(port = CN_USART1;port < CN_UART_NUM; port ++)
    {
        if(huart == spHuart[port])
            break;
    }
    __UART_RCC_Enable(port,1);
}
void HAL_USART_MspInit(USART_HandleTypeDef *huart)
{
    u8 port;
    for(port = CN_USART1;port < CN_UART_NUM; port ++)
    {
        if(huart == spHuart[port])
            break;
    }
    __UART_RCC_Enable(port,1);
}

// =============================================================================
// 功能: 硬件参数配置和寄存器的初始化，包括波特率、停止位、校验位、数据位，默认情况下:
//       波特率:115200  ； 停止位:1 ; 校验:无 ; 数据位:8bit
// 参数: SerialNo,串口号，0~3
// 返回: 无
// =============================================================================
static void __UART_HardInit(u8 port)
{
    UART_InitTypeDef  *Init;
    USART_InitTypeDef  *InitS;
    u32 size;
    if(port < CN_UART_NUM)
    {
        __UART_RCC_Enable(port,1);
        if(sUartCfg[port].isUart == IAM_UART)
        {
            size = sizeof(UART_HandleTypeDef);
            spHuart[port] = (u8*)malloc(size + CFG_UART_SENDBUF_LEN + CFG_UART_RECVBUF_LEN);
            pUartSndBuf[port] = (u8*)spHuart[port] + size;
            pUartRcvBuf[port] = pUartSndBuf[port] + CFG_UART_SENDBUF_LEN;

            Init = &((UART_HandleTypeDef*)spHuart[port])->Init;
            Init->BaudRate               = 115200;
            Init->WordLength             = UART_WORDLENGTH_8B;
            Init->Parity                 = UART_PARITY_NONE;
            Init->StopBits               = UART_STOPBITS_1;
            Init->Mode                   = UART_MODE_TX_RX;
            Init->HwFlowCtl              = UART_HWCONTROL_NONE;
            Init->OneBitSampling         = UART_ONE_BIT_SAMPLE_ENABLE;
            Init->OverSampling           = UART_OVERSAMPLING_16;
            ((UART_HandleTypeDef*)spHuart[port])->Instance = sUartCfg[port].Reg;
            ((UART_HandleTypeDef*)spHuart[port])->AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
            HAL_UART_DeInit((UART_HandleTypeDef*)spHuart[port]);
            HAL_UART_Init((UART_HandleTypeDef*)spHuart[port]);
            HAL_UARTEx_EnableFifoMode((UART_HandleTypeDef*)spHuart[port]);
            HAL_UARTEx_SetTxFifoThreshold((UART_HandleTypeDef*)spHuart[port],USART_TXFIFO_THRESHOLD_1_2);
            HAL_UARTEx_SetRxFifoThreshold((UART_HandleTypeDef*)spHuart[port],USART_RXFIFO_THRESHOLD_1_2);
            HAL_UARTEx_EnableFifoMode((UART_HandleTypeDef*)spHuart[port]);
        }
        else
        {
            size = sizeof(USART_HandleTypeDef);
            spHuart[port] = (u8*)malloc(size + CFG_UART_SENDBUF_LEN + CFG_UART_RECVBUF_LEN);
            pUartSndBuf[port] = (u8*)spHuart[port] + size;
            pUartRcvBuf[port] = pUartSndBuf[port] + CFG_UART_SENDBUF_LEN;

            InitS = &((USART_HandleTypeDef*)spHuart[port])->Init;
            InitS->BaudRate               = 115200;
            InitS->WordLength             = UART_WORDLENGTH_8B;
            InitS->Parity                 = UART_PARITY_NONE;
            InitS->StopBits               = UART_STOPBITS_1;
            InitS->Mode                   = UART_MODE_TX_RX;
            ((USART_HandleTypeDef*)spHuart[port])->Instance = sUartCfg[port].Reg;
            HAL_USART_DeInit((USART_HandleTypeDef*)spHuart[port]);
            HAL_USART_Init((USART_HandleTypeDef*)spHuart[port]);
            HAL_USARTEx_EnableFifoMode((USART_HandleTypeDef*)spHuart[port]);
            HAL_USARTEx_SetTxFifoThreshold((USART_HandleTypeDef*)spHuart[port],USART_TXFIFO_THRESHOLD_1_2);
            HAL_USARTEx_SetRxFifoThreshold((USART_HandleTypeDef*)spHuart[port],USART_RXFIFO_THRESHOLD_1_2);
            HAL_USARTEx_EnableFifoMode((USART_HandleTypeDef*)spHuart[port]);
        }
        __UART_StartRecv(port);
    }
}

// =============================================================================
// 功能: 启动串口发送，包括两种情况，使用DMA或不使用DMA
// 参数: Reg,被操作的串口寄存器指针.
// 返回: 发送的个数
// =============================================================================
static u32 __UART_SendStart (u16 port)
{
    u16 len=0;
    HAL_StatusTypeDef Ret;

    Board_UartHalfDuplexSend(port);
    if(port < CN_UART_NUM)
    {
        if(!sUartSending[port])
        {
            len = UART_PortRead(pUartCB[port],pUartSndBuf[port],CFG_UART_SENDBUF_LEN);
            if(len > 0)
            {
                sUartSending[port] = true;
                if(sUartCfg[port].isUart == IAM_UART)
                {
                    if(sUartDmaUsed[port])
                    {
                        Ret = HAL_UART_Transmit_DMA((UART_HandleTypeDef*)spHuart[port],pUartSndBuf[port],len);
                    }
                    else
                    {
                        Ret = HAL_UART_Transmit_IT((UART_HandleTypeDef*)spHuart[port],pUartSndBuf[port],len);
                    }
                }
                else
                {
                    if(sUartDmaUsed[port])
                    {
                        Ret = HAL_USART_Transmit_DMA((USART_HandleTypeDef*)spHuart[port],pUartSndBuf[port],len);
                    }
                    else
                    {
                        Ret = HAL_USART_Transmit_IT((USART_HandleTypeDef*)spHuart[port],pUartSndBuf[port],len);
                    }
                }
                if(Ret != HAL_OK)
                {
                    sUartSending[port] = false;
                    Board_UartHalfDuplexRecv(port);
                }
            }
        }
    }

    return len;
}

// =============================================================================
// 功能：配置是否使用DMA传输，
// 参数：port，使用的串口号
//      enable,1 or 0,使能或禁能
// 返回：无
// =============================================================================
void __UART_SetDmaUsed(u8 port,u8 enable)
{
    u8 IntLine;
    DMA_HandleTypeDef        *hdmatx;                  /*!< UART Tx DMA Handle parameters      */
    DMA_HandleTypeDef        *hdmarx;                  /*!< UART Rx DMA Handle parameters      */
    if(sUartCfg[port].isUart == IAM_UART)
    {
        hdmatx = ((UART_HandleTypeDef *)spHuart[port])->hdmatx;
        hdmarx = ((UART_HandleTypeDef *)spHuart[port])->hdmarx;
    }
    else
    {
        hdmatx = ((USART_HandleTypeDef *)spHuart[port])->hdmatx;
        hdmarx = ((USART_HandleTypeDef *)spHuart[port])->hdmarx;
    }

    if( (false == sUartDmaUsed[port]) && (enable) )
    {
        __HAL_RCC_DMA1_CLK_ENABLE();
        __HAL_RCC_DMA2_CLK_ENABLE();
        HAL_UART_Abort(&spHuart[port]);

        if(hdmarx == NULL)
        {
            hdmarx = (DMA_HandleTypeDef*)malloc(2*sizeof(DMA_HandleTypeDef));
            if(NULL == hdmarx)
                return;
            hdmatx = hdmarx + 1;
            if(sUartCfg[port].isUart == IAM_UART)
            {
                ((UART_HandleTypeDef *)spHuart[port])->hdmatx = hdmatx;
                ((UART_HandleTypeDef *)spHuart[port])->hdmarx = hdmarx;
            }
            else
            {
                ((USART_HandleTypeDef *)spHuart[port])->hdmatx = hdmatx;
                ((USART_HandleTypeDef *)spHuart[port])->hdmarx = hdmarx;
            }
        }

        hdmarx->Instance = sUartCfg[port].DmaRxCh;
        hdmarx->Init.Direction = DMA_PERIPH_TO_MEMORY;
        hdmarx->Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
        hdmarx->Init.MemInc = DMA_MINC_ENABLE;
        hdmarx->Init.Mode = DMA_CIRCULAR;
        hdmarx->Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
        hdmarx->Init.PeriphInc = DMA_PINC_DISABLE;
        hdmarx->Init.Priority = DMA_PRIORITY_HIGH;
        hdmarx->Init.Request = sUartCfg[port].DmaRxReq;
        hdmarx->XferCpltCallback = 0;
        hdmarx->XferHalfCpltCallback = 0;
        hdmarx->XferErrorCallback = 0;
        hdmarx->Parent = (void*)&spHuart[port];

        hdmatx->Instance = sUartCfg[port].DmaTxCh;
        hdmatx->Init.Direction = DMA_MEMORY_TO_PERIPH;
        hdmatx->Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
        hdmatx->Init.MemInc = DMA_MINC_ENABLE;
        hdmatx->Init.Mode = DMA_NORMAL;
        hdmatx->Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
        hdmatx->Init.PeriphInc = DMA_PINC_DISABLE;
        hdmatx->Init.Priority = DMA_PRIORITY_LOW;
        hdmatx->Init.Request = sUartCfg[port].DmaTxReq;
        hdmatx->XferCpltCallback = 0;
        hdmatx->XferErrorCallback = 0;
        hdmatx->XferHalfCpltCallback = 0;
        hdmatx->Parent = (void*)&spHuart[port];
        HAL_DMA_Init(hdmatx);
        HAL_DMA_Init(hdmarx);

        sUartCfg[port].Reg->ICR = USART_ICR_IDLECF; //clear the status flag
        sUartCfg[port].Reg->CR1 |= USART_CR1_IDLEIE;//enable idle int
        sUartDmaUsed[port] = true;

        IntLine = sUartCfg[port].DmaRxIntLine;
        Int_Register(IntLine);
        Int_SetClearType(IntLine,CN_INT_CLEAR_AUTO);
        Int_IsrConnect(IntLine,(u32(*)(ptu32_t))HAL_DMA_IRQHandler);
        Int_SetIsrPara(IntLine,(ptu32_t)hdmarx);
        Int_SettoAsynSignal(IntLine);
        Int_ClearLine(IntLine);
        Int_RestoreAsynLine(IntLine);

        IntLine = sUartCfg[port].DmaTxIntLine;
        Int_Register(IntLine);
        Int_SetClearType(IntLine,CN_INT_CLEAR_AUTO);
        Int_IsrConnect(IntLine,(u32(*)(ptu32_t))HAL_DMA_IRQHandler);
        Int_SetIsrPara(IntLine,(ptu32_t)hdmatx);
        Int_SettoAsynSignal(IntLine);
        Int_ClearLine(IntLine);
        Int_RestoreAsynLine(IntLine);
    }
    else if( (sUartDmaUsed[port]) && (!enable) )
    {
        HAL_UART_Abort(&spHuart[port]);
        free(hdmarx);
        if(sUartCfg[port].isUart == IAM_UART)
        {
            ((UART_HandleTypeDef *)spHuart[port])->hdmatx = NULL;
            ((UART_HandleTypeDef *)spHuart[port])->hdmarx = NULL;
        }
        else
        {
            ((USART_HandleTypeDef *)spHuart[port])->hdmatx = NULL;
            ((USART_HandleTypeDef *)spHuart[port])->hdmarx = NULL;
        }

        sUartCfg[port].Reg->ICR = USART_ICR_IDLECF;
        sUartCfg[port].Reg->CR1 &= ~USART_CR1_IDLEIE;
        sUartDmaUsed[port] = false;

        IntLine = sUartCfg[port].DmaRxIntLine;
        Int_IsrDisConnect(IntLine);
        Int_ClearLine(IntLine);
        Int_UnRegister(IntLine);

        IntLine = sUartCfg[port].DmaTxIntLine;
        Int_IsrDisConnect(IntLine);
        Int_ClearLine(IntLine);
        Int_UnRegister(IntLine);
    }
    else
    {

    }
    __UART_StartRecv(port);
}
// =============================================================================
// 功能: 串口设备的控制函数,与具体的硬件寄存器设置相关
// 参数: Reg,被操作的串口寄存器指针.
//       cmd,操作类型
//       data1,data2,含义依cmd而定
// 返回: 无意义.
// =============================================================================
static ptu32_t __UART_Ctrl(u32 port,u32 cmd, va_list *arg0)
{
    ptu32_t result = 0;
    u32 timeout = 100000;

    if(port < CN_UART_NUM)
    {
        switch(cmd)
        {
        case CN_DEV_CTRL_START:
            __UART_Start(port);
            break;
        case CN_DEV_CTRL_STOP:
            __UART_Stop(port);
            break;
        case CN_DEV_CTRL_SHUTDOWN:
            break;
        case CN_DEV_CTRL_SLEEP:
            break;
        case CN_DEV_CTRL_RESUME:
            break;
        case CN_UART_SET_BAUD:
        {
            u32 data;
            data = va_arg(*arg0, u32);
            __UART_BaudSet(port, data);
        }
            break;
        case CN_UART_COM_SET:
        {
            struct COMParam *COM;
            COM = va_arg(*arg0, void *);
            __UART_ComConfig(port,COM);
        }
            break;

        case CN_UART_DMA_USED:
            __UART_SetDmaUsed(port,1);
            break;
        case CN_UART_DMA_UNUSED:
            __UART_SetDmaUsed(port,0);
            break;
        default:
            break;
        }
    }
    return result;
}

// =============================================================================
// 功能：发送完成回调函数，由HAL中断函数调用，若DMA中断调用此函数，由必然是配置的传送长度
//      完成，若传送完成，需配置发送ING标记为false
// 参数：huart，HAL提供的UARTHandler
// 返回：无
// =============================================================================
void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)
{
    u16 port,len;
    for(port = CN_USART1;port < CN_UART_NUM; port ++)
    {
        if(huart == spHuart[port])
            break;
    }
    if(port < CN_UART_NUM)
    {
        len = UART_PortRead(pUartCB[port],pUartSndBuf[port],CFG_UART_SENDBUF_LEN);
        if(len > 0)
        {
            if(sUartDmaUsed[port])
                HAL_UART_Transmit_DMA((UART_HandleTypeDef*)spHuart[port],pUartSndBuf[port],len);
            else
                HAL_UART_Transmit_IT((UART_HandleTypeDef*)spHuart[port],pUartSndBuf[port],len);
        }
        else
        {
            Board_UartHalfDuplexRecv(port);
            sUartSending[port] = false;
        }
    }
}
void HAL_USART_TxCpltCallback(USART_HandleTypeDef *huart)
{
    u16 port,len;
    for(port = CN_USART1;port < CN_UART_NUM; port ++)
    {
        if(huart == spHuart[port])
            break;
    }
    if(port < CN_UART_NUM)
    {
        len = UART_PortRead(pUartCB[port],pUartSndBuf[port],CFG_UART_SENDBUF_LEN);
        if(len > 0)
        {
            if(sUartDmaUsed[port])
                HAL_USART_Transmit_DMA((USART_HandleTypeDef*)spHuart[port],pUartSndBuf[port],len);
            else
                HAL_USART_Transmit_IT((USART_HandleTypeDef*)spHuart[port],pUartSndBuf[port],len);
        }
        else
        {
            Board_UartHalfDuplexRecv(port);
            sUartSending[port] = false;
        }
    }
}


// =============================================================================
// 功能：接收完成回调函数，包括DMA接收完成，由HAL中断函数调用，若DMA中断调用此函数，由必然
//      是配置的传送长度完成，即下面代码中的num == UART_RxBufLen
// 参数：huart，HAL提供的UARTHandler
// 返回：无
// =============================================================================
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{
    u8 port,num;
    u8 *src;
    for(port = CN_USART1;port < CN_UART_NUM; port ++)
    {
        if(huart == spHuart[port])
            break;
    }
    if(port < CN_UART_NUM)
    {
        if(sUartDmaUsed[port])
        {
            num = CFG_UART_RECVBUF_LEN - sDmaRcvOff[port];
            src = pUartRcvBuf[port] + sDmaRcvOff[port];
            if(num != UART_PortWrite(pUartCB[port],src,num))
            {
                UART_ErrHandle(pUartCB[port],CN_UART_BUF_OVER_ERR);
            }
            sDmaRcvOff[port] = 0;
        }
        else
        {
            num = UART_PortWrite(pUartCB[port],pUartRcvBuf[port],1);
            if(num != 1)
            {
                UART_ErrHandle(pUartCB[port],CN_UART_BUF_OVER_ERR);
            }
            HAL_UART_Receive_IT((UART_HandleTypeDef*)spHuart[port],pUartRcvBuf[port],1);
        }
    }
}

void HAL_UART_RxHalfCpltCallback(UART_HandleTypeDef *huart)//半传输中断
{
    u8 port,num;
    u8 *src;
    for(port = CN_USART1;port < CN_UART_NUM; port ++)
    {
        if(huart == spHuart[port])
            break;
    }
    if(port < CN_UART_NUM)
    {
        if(sUartDmaUsed[port])
        {
            num = CFG_UART_RECVBUF_LEN/2 - sDmaRcvOff[port];
            src = pUartRcvBuf[port] + sDmaRcvOff[port];
            if(num != UART_PortWrite(pUartCB[port],src,num))
            {
                UART_ErrHandle(pUartCB[port],CN_UART_BUF_OVER_ERR);
            }
            sDmaRcvOff[port] = CFG_UART_RECVBUF_LEN/2;
        }
        else
        {
            num = UART_PortWrite(pUartCB[port],pUartRcvBuf[port],1);
            if(num != 1)
            {
                UART_ErrHandle(pUartCB[port],CN_UART_BUF_OVER_ERR);
            }
            HAL_UART_Receive_IT((UART_HandleTypeDef*)spHuart[port],pUartRcvBuf[port],1);
        }
    }
}
void HAL_USART_RxCpltCallback(USART_HandleTypeDef *huart)
{
    u8 port,num;
    u8 *src;
    for(port = CN_USART1;port < CN_UART_NUM; port ++)
    {
        if(huart == spHuart[port])
            break;
    }
    if(port < CN_UART_NUM)
    {
        if(sUartDmaUsed[port])
        {
            num = CFG_UART_RECVBUF_LEN - sDmaRcvOff[port];
            src = pUartRcvBuf[port] + sDmaRcvOff[port];
            if(num != UART_PortWrite(pUartCB[port],src,num))
            {
                UART_ErrHandle(pUartCB[port],CN_UART_BUF_OVER_ERR);
            }
            sDmaRcvOff[port] = 0;
        }
        else
        {
            num = UART_PortWrite(pUartCB[port],pUartRcvBuf[port],1);
            if(num != 1)
            {
                UART_ErrHandle(pUartCB[port],CN_UART_BUF_OVER_ERR);
            }
            HAL_USART_Receive_IT((USART_HandleTypeDef*)spHuart[port],pUartRcvBuf[port],1);
        }
    }
}

void HAL_USART_RxHalfCpltCallback(USART_HandleTypeDef *huart)//半传输中断
{
    u8 port,num;
    u8 *src;
    for(port = CN_USART1;port < CN_UART_NUM; port ++)
    {
        if(huart == spHuart[port])
            break;
    }
    if(port < CN_UART_NUM)
    {
        if(sUartDmaUsed[port])
        {
            num = CFG_UART_RECVBUF_LEN/2 - sDmaRcvOff[port];
            src = pUartRcvBuf[port] + sDmaRcvOff[port];
            if(num != UART_PortWrite(pUartCB[port],src,num))
            {
                UART_ErrHandle(pUartCB[port],CN_UART_BUF_OVER_ERR);
            }
            sDmaRcvOff[port] = CFG_UART_RECVBUF_LEN/2;
        }
        else
        {
            num = UART_PortWrite(pUartCB[port],pUartRcvBuf[port],1);
            if(num != 1)
            {
                UART_ErrHandle(pUartCB[port],CN_UART_BUF_OVER_ERR);
            }
            HAL_USART_Receive_IT((USART_HandleTypeDef*)spHuart[port],pUartRcvBuf[port],1);
        }
    }
}

void HAL_UARTEx_RxFifoFullCallback(UART_HandleTypeDef *huart)
{
    u8 port,num;
    u8 *src;
    for(port = CN_USART1;port < CN_UART_NUM; port ++)
    {
        if(huart == spHuart[port])
            break;
    }

}

void HAL_UARTEx_TxFifoEmptyCallback(UART_HandleTypeDef *huart)
{
    u8 port,num;
    u8 *src;
    for(port = CN_USART1;port < CN_UART_NUM; port ++)
    {
        if(huart == spHuart[port])
            break;
    }

}
void HAL_USARTEx_RxFifoFullCallback(USART_HandleTypeDef *huart)
{
    u8 port,num;
    u8 *src;
    for(port = CN_USART1;port < CN_UART_NUM; port ++)
    {
        if(huart == spHuart[port])
            break;
    }

}

void HAL_USARTEx_TxFifoEmptyCallback(USART_HandleTypeDef *huart)
{
    u8 port,num;
    u8 *src;
    for(port = CN_USART1;port < CN_UART_NUM; port ++)
    {
        if(huart == spHuart[port])
            break;
    }

}
// =============================================================================
// 功能：发生错误回调函数，例如发生奇偶校验错误、硬件错误等HAL会调用此函数
// 参数：huart，HAL提供的UARTHandler
// 返回：无
// =============================================================================
void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart)
{
    u8 port;
    for(port = CN_USART1;port < CN_UART_NUM; port ++)
    {
        if(huart == spHuart[port])
            break;
    }
    if(port < CN_UART_NUM)
    {
        UART_ErrHandle(pUartCB[port],CN_UART_HARD_COMM_ERR);
        printk("Uart hard error!\r\n");
    }
}
// =============================================================================
// 功能：UART中断,若为idle中断，则从DMA缓冲区中读出数据，并重新启动DMA，否则调用HAL中断
//       处理函数，最终会调用到HAL_UART_XXXXCallback（）
// 参数：串口号
// 返回：1=成功，0=失败
// =============================================================================
u32 UART_ISR(ptu32_t port)
{
    u32 num;
    tagUartReg volatile *Reg;
    u8 *src,temp;
    DMA_HandleTypeDef          *hdmarx;                      /*!< Rx DMA Handle parameters             */

    if(port >= CN_UART_NUM)
        return 0;
    if(sUartCfg[port].isUart == IAM_UART)
    {
        hdmarx = ((UART_HandleTypeDef *)spHuart[port])->hdmarx;
    }
    else
    {
        hdmarx = ((USART_HandleTypeDef *)spHuart[port])->hdmarx;
    }

    Reg = sUartCfg[port].Reg;
    if( (Reg->ISR & USART_ISR_IDLE) && (sUartDmaUsed[port]) )
    {
        Reg->ICR = USART_ICR_IDLECF;    //clear the status flag

        temp = CFG_UART_RECVBUF_LEN - ((DMA_Stream_TypeDef *)hdmarx->Instance)->NDTR;
        num =  temp -sDmaRcvOff[port];
        src = pUartRcvBuf[port] + sDmaRcvOff[port];
        if(num != UART_PortWrite(pUartCB[port],src,num))
        {
            UART_ErrHandle(pUartCB[port],CN_UART_BUF_OVER_ERR);
        }
        sDmaRcvOff[port] = temp;
    }
    else
    {
        if(sUartCfg[port].isUart == IAM_UART)
        {
            HAL_UART_IRQHandler((UART_HandleTypeDef*)spHuart[port]);
        }
        else
        {
            HAL_USART_IRQHandler((USART_HandleTypeDef*)spHuart[port]);
        }

    }

    return 1;
}

// =============================================================================
// 功能：初始化uart1模块,并装载串口设备，会调用uart.c的API函数。该函数主要完成的功能
//       如下：
//       1.初始化串口的硬件部分，如GPIO、中断、配置配置的COM参数，配置baud = 115200
//         stop bits = 1,无奇偶校验, data bits = 8
//       2.调用uart.c的API函数UART_InstallPort，装入串口设备
// 参数：串口号，0~3
// 返回：1=成功，0=失败
// =============================================================================
ptu32_t ModuleInstall_UART(u32 port)
{
    struct UartParam UART_Param;

    if(port >= CN_UART_NUM)
        return false;
    UART_Param.Name         = sUartCfg[port].Name;
    UART_Param.UartPortTag  = (ptu32_t)port;
    UART_Param.Baud         = 115200;
    UART_Param.TxRingBufLen = CFG_UART_SENDBUF_LEN;
    UART_Param.RxRingBufLen = CFG_UART_RECVBUF_LEN;
    UART_Param.StartSend    = (UartStartSend)__UART_SendStart;
    UART_Param.UartCtrl     = (UartControl)__UART_Ctrl;
    UART_Param.mode         = CN_UART_GENERAL;

    pUartCB[port] = UART_InstallGeneral(&UART_Param);

    if ( pUartCB[port] != NULL)
    {
        __UART_HardInit(port);              //硬件初始化
        __UART_IntInit(port);
        return true;
    }
    return false;
}

// =============================================================================
// 功能：字符终端直接发送函数，采用轮询方式，直接写寄存器，用于printk，或者stdout
//       没有初始化
// 参数：str，发送字符串指针
//      len，发送的字节数
// 返回：0，发生错误；result,发送数据长度，字节单位
// =============================================================================
s32 Uart_PutStrDirect(const char *str,u32 len)
{
    u32 timeout;
    HAL_StatusTypeDef res;
    TxByteTime = 11000000/115200;

    timeout= TxByteTime * len;
    if(sUartCfg[TxDirectPort].isUart == IAM_UART)
    {
        res = HAL_UART_Transmit((UART_HandleTypeDef*)PutStrDirectH,(u8*)str,len,timeout);
    }
    else
    {
        res = HAL_USART_Transmit((USART_HandleTypeDef*)PutStrDirectH,(u8*)str,len,timeout);
    }

    if(res != HAL_OK)
        return 0;
    else
        return len;
}

// =============================================================================
// 功能：字符终端直接接收函数，采用轮询方式，直接读寄存器，用于stdin初始化前
// 参数：str，发送字符串指针
//      len，发送的字节数
// 返回：0，发生错误；result,发送数据长度，字节单位
// =============================================================================
char Uart_GetCharDirect(void)
{
    HAL_StatusTypeDef res;
    u8 result;
    while(1)
    {
        if(sUartCfg[RxDirectPort].isUart == IAM_UART)
        {
            res = HAL_UART_Receive((UART_HandleTypeDef*)GetCharDirectH,&result,1,0);
        }
        else
        {
            res = HAL_USART_Receive((USART_HandleTypeDef*)GetCharDirectH,&result,1,0);
        }
        if(HAL_OK != res)
            DJY_EventDelay(500);
        else
            break;
    }
    return result;
}

//----初始化内核级IO-----------------------------------------------------------
//功能：初始化内核级输入和输出所需的runtime函数指针。
//参数：无
//返回：无
//-----------------------------------------------------------------------------
void Stdio_KnlInOutInit(char * StdioIn, char *StdioOut)
{
    if(!strcmp(StdioOut,"/dev/UART1"))
    {
        TxDirectPort = CN_USART1;
    }
    else if(!strcmp(StdioOut,"/dev/UART2"))
    {
        TxDirectPort = CN_USART2;
    }
    else if(!strcmp(StdioOut,"/dev/UART3"))
    {
        TxDirectPort = CN_USART3;
    }
    else if(!strcmp(StdioOut,"/dev/UART4"))
    {
        TxDirectPort = CN_UART4;
    }
    else if(!strcmp(StdioOut,"/dev/UART5"))
    {
        TxDirectPort = CN_UART5;
    }
    else if(!strcmp(StdioOut,"/dev/UART6"))
    {
        TxDirectPort = CN_USART6;
    }
    else if(!strcmp(StdioOut,"/dev/UART7"))
    {
        TxDirectPort = CN_UART7;
    }
    else if(!strcmp(StdioOut,"/dev/UART8"))
    {
        TxDirectPort = CN_UART8;
    }
    else if(!strcmp(StdioOut,"/dev/UART9"))
    {
        TxDirectPort = CN_UART9;
    }
    else if(!strcmp(StdioOut,"/dev/UART10"))
    {
        TxDirectPort = CN_USART10;
    }
    else
    {
        TxDirectPort = -1 ;
    }

    if(TxDirectPort != -1)
    {
        __UART_HardInit(TxDirectPort);
        PutStrDirectH = spHuart[TxDirectPort];  //spHuart在__UART_HardInit中初始化
        TxByteTime = 95;      //初始化默认115200，发送一个byte是87uS,+10%容限
        PutStrDirect = Uart_PutStrDirect;
    }

    if(!strcmp(StdioIn,"/dev/UART1"))
    {
        RxDirectPort = CN_USART1;
    }
    else if(!strcmp(StdioIn,"/dev/UART2"))
    {
        RxDirectPort = CN_USART2;
    }
    else if(!strcmp(StdioIn,"/dev/UART3"))
    {
        RxDirectPort = CN_USART3;
    }
    else if(!strcmp(StdioIn,"/dev/UART4"))
    {
        RxDirectPort = CN_UART4;
    }
    else if(!strcmp(StdioIn,"/dev/UART5"))
    {
        RxDirectPort = CN_UART5;
    }
    else if(!strcmp(StdioIn,"/dev/UART6"))
    {
        RxDirectPort = CN_USART6;
    }
    else if(!strcmp(StdioIn,"/dev/UART7"))
    {
        RxDirectPort = CN_UART7;
    }
    else if(!strcmp(StdioIn,"/dev/UART8"))
    {
        RxDirectPort = CN_UART8;
    }
    else if(!strcmp(StdioIn,"/dev/UART9"))
    {
        RxDirectPort = CN_UART9;
    }
    else if(!strcmp(StdioIn,"/dev/UART10"))
    {
        RxDirectPort = CN_USART10;
    }
    else
    {
        RxDirectPort = -1;
    }

    if(RxDirectPort != -1)
    {
        if(TxDirectPort != RxDirectPort)
            __UART_HardInit(RxDirectPort);
        GetCharDirectH = spHuart[RxDirectPort];
        GetCharDirect = Uart_GetCharDirect;
    }
    return;
}



