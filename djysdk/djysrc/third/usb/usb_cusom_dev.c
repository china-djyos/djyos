//-----------------------------------------------------------------------------// Copyright (c) 2014, SHENZHEN PENGRUI SOFT CO LTD. All rights reserved.// Redistribution and use in source and binary forms, with or without// modification, are permitted provided that the following conditions are met:// 1. Redistributions of source code must retain the above copyright notice,//    this list of conditions and the following disclaimer.// 2. Redistributions in binary form must reproduce the above copyright notice,//    this list of conditions and the following disclaimer in the documentation//    and/or other materials provided with the distribution.// 3. As a constituent part of djyos,do not transplant it to other software//    without specific prior written permission.// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE// POSSIBILITY OF SUCH DAMAGE.//-----------------------------------------------------------------------------// Copyright (c) 2014 著作权由深圳鹏瑞软件有限公司所有。著作权人保留一切权利。//// 这份授权条款，在使用者符合以下三条件的情形下，授予使用者使用及再散播本// 软件包装原始码及二进位可执行形式的权利，无论此包装是否经改作皆然：//// 1. 对于本软件源代码的再散播，必须保留上述的版权宣告、本条件列表，以//    及下述的免责声明。// 2. 对于本套件二进位可执行形式的再散播，必须连带以文件以及／或者其他附//    于散播包装中的媒介方式，重制上述之版权宣告、本条件列表，以及下述//    的免责声明。// 3. 本软件作为都江堰操作系统的组成部分，未获事前取得的书面许可，不允许移植到非//    都江堰操作系统环境下运行。// 免责声明：本软件是本软件版权持有人以及贡献者以现状（"as is"）提供，// 本软件包装不负任何明示或默示之担保责任，包括但不限于就适售性以及特定目// 的的适用性为默示性担保。版权持有人及本软件之贡献者，无论任何条件、// 无论成因或任何责任主义、无论此责任为因合约关系、无过失责任主义或因非违// 约之侵权（包括过失或其他原因等）而起，对于任何因使用本软件包装所产生的// 任何直接性、间接性、偶发性、特殊性、惩罚性或任何结果的损害（包括但不限// 于替代商品或劳务之购用、使用损失、资料损失、利益损失、业务中断等等），// 不负任何责任，即在该种使用已获事前告知可能会造成此类损害的情形下亦然。//-----------------------------------------------------------------------------#include <stddef.h>#include <stdlib.h>#include <driver.h>#include "./stm32_usb_host_library/class/custom/inc/usbh_custom.h"#include "usb.h"static tagDeviceUSB *pCUSTOMs;//-----------------------------------------------------------------------------//功能: 通过AT接口发送数据//参数: pBuf -- 命令；dwLen -- 命令字节长；dwOffset（未用）；dwTimeout -- 等待完成时间。//返回: len -- 发送字节数；//备注: dwTimeout为零，则采用默认的等待时间。//-----------------------------------------------------------------------------u32 USBH_WriteAT(ptu32_t pUSB, u8 *pBuf, u32 dwLen, u32 dwOffset, bool_t dwBlock, u32 dwTimeout){	USBH_HandleTypeDef *host = (USBH_HandleTypeDef*)pUSB;	u8 *command = pBuf;	u32 len = dwLen;	u32 timeout = dwTimeout;	USBH_CUSTOM_AT_Transmit(host, command, &len, timeout);	return (dwLen - len);}//-----------------------------------------------------------------------------//功能: 通过AT接口接收数据//参数: pBuf -- 数据缓冲；dwLen -- 数据字节长；dwOffset（未用）；dwTimeout -- 等待完成时间。//返回: len -- 接收字节数；//备注: dwTimeout为零，则采用默认的等待时间。//-----------------------------------------------------------------------------u32 USBH_ReadAT(ptu32_t pUSB, u8 *pBuf, u32 dwLen, u32 wdOffset, u32 dwTimeout){	USBH_HandleTypeDef *host = (USBH_HandleTypeDef*)pUSB;	u8 *command = pBuf;	u32 len = dwLen;	u32 timeout = dwTimeout;	USBH_CUSTOM_AT_Receive(host, command, &len, timeout);	return (dwLen - len);}//-----------------------------------------------------------------------------//功能: 通过MODEM接口发送数据//参数: pBuf -- 命令；dwLen -- 命令字节长；dwOffset（未用）；dwTimeout -- 等待完成时间。//返回: 0 -- 发送字节数；//备注: dwTimeout为零，则采用默认的等待时间。//-----------------------------------------------------------------------------u32 USBH_WriteMODEM(ptu32_t pUSB, u8 *pBuf, u32 dwLen, u32 dwOffset, bool_t dwBlock, u32 dwTimeout){	USBH_HandleTypeDef *host = (USBH_HandleTypeDef*)pUSB;	u8 *command = pBuf;	u32 len = dwLen;	u32 timeout = dwTimeout;	USBH_CUSTOM_MODEM_Transmit(host, command, &len, timeout);	return (dwLen - len);}//-----------------------------------------------------------------------------//功能: 通过MODEM接口接收数据//参数: pBuf -- 数据缓冲；dwLen -- 数据字节长；dwOffset（未用）；dwTimeout -- 等待完成时间。//返回: 0 -- 接收字节数；//备注: dwTimeout为零，则采用默认的等待时间。//-----------------------------------------------------------------------------u32 USBH_ReadMODEM(ptu32_t pUSB, u8 *pBuf, u32 dwLen, u32 dwOffset, u32 dwTimeout){	USBH_HandleTypeDef *host = (USBH_HandleTypeDef*)pUSB;	u8 *command = pBuf;	u32 len = dwLen;	u32 timeout = dwTimeout;	USBH_CUSTOM_MODEM_Receive(host, command, &len, timeout);	return (dwLen - len);}//-----------------------------------------------------------------------------//功能: 通过DEBUG接口发送数据//参数: pBuf -- 命令；dwLen -- 命令字节长；dwOffset（未用）；dwTimeout -- 等待完成时间。//返回: 0 -- 发送字节数；//备注: dwTimeout为零，则采用默认的等待时间。//-----------------------------------------------------------------------------u32 USBH_WriteDEBUG(ptu32_t pUSB, u8 *pBuf, u32 dwLen, u32 dwOffset, bool_t dwBlock, u32 dwTimeout){	USBH_HandleTypeDef *host = (USBH_HandleTypeDef*)pUSB;	u8 *command = pBuf;	u32 len = dwLen;	u32 timeout = dwTimeout;	USBH_CUSTOM_DEBUG_Transmit(host, command, &len, timeout);	return (dwLen - len);}//-----------------------------------------------------------------------------//功能: 通过DEBUG接口接收数据//参数: pBuf -- 数据缓冲；dwLen -- 数据字节长；dwOffset（未用）；dwTimeout -- 等待完成时间。//返回: 0 -- 接收字节数；//备注: dwTimeout为零，则采用默认的等待时间。//-----------------------------------------------------------------------------u32 USBH_ReadDEBUG(ptu32_t pUSB, u8 *pBuf, u32 dwLen, u32 dwOffset, u32 dwTimeout){	USBH_HandleTypeDef *host = (USBH_HandleTypeDef*)pUSB;	u8 *command = pBuf;	u32 len = dwLen;	u32 timeout = dwTimeout;	USBH_CUSTOM_DEBUG_Receive(host, command, &len, timeout);	return (dwLen - len);}//-----------------------------------------------------------------------------//功能: 查询模块状态//参数://返回: 0 -- 已就绪； 1 -- 未就绪；//备注://-----------------------------------------------------------------------------s32 CUSTOM_DeviceReady(void){	return (USBH_DeviceQuery(0, pCUSTOMs));}//-----------------------------------------------------------------------------//功能: 注册USB设备//参数://返回://备注://-----------------------------------------------------------------------------s32 USBH_RegisterCUSTOM_Device(u8 bController){	struct DjyDevice *devAT = NULL, *devMODEM = NULL, *devDBG = NULL;	static char *name[] = {"uat", "umodem", "udbg"};	USBH_HandleTypeDef *controller;	tagDeviceUSB *custom;		controller = USBH_HostHandle(bController);	if(!controller)		return (-1);	custom = USBH_NewDevice(pCUSTOMs, bController);	if(!custom)		return (-1);	if(!pCUSTOMs)		pCUSTOMs = custom;	devAT = Driver_DeviceCreate(NULL, (const char*)name[0], NULL, NULL,			USBH_WriteAT, USBH_ReadAT, NULL, NULL, ((ptu32_t)controller));	if(!devAT)	{		return (-1);	}	devMODEM = Driver_DeviceCreate(NULL, (const char*)name[1], NULL, NULL,			USBH_WriteMODEM, USBH_ReadMODEM, NULL, NULL, ((ptu32_t)controller));	if(!devMODEM)	{		// register device "usb modem" failure		goto FAIL;	}	devDBG = Driver_DeviceCreate(NULL, (const char*)name[2], NULL, NULL,			USBH_WriteDEBUG, USBH_ReadDEBUG, NULL, NULL, ((ptu32_t)controller));	if(!devDBG)	{		// register device "usb debug" failure		goto FAIL;	}	return (0); //FAIL:	if(devAT)		Driver_DeleteDevice(devAT); // unregister device "usb at"	if(devMODEM)		Driver_DeleteDevice(devMODEM); // unregister device "usb modem"	if(devDBG)		Driver_DeleteDevice(devDBG); // unregister device "usb debug"	return (-1);}